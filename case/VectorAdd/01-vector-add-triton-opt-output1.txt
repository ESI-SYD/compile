// -----// IR Dump After Canonicalizer (canonicalize) //----- //
tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
  %c1024_i32 = arith.constant 1024 : i32
  %0 = tt.get_program_id x : i32
  %1 = arith.muli %0, %c1024_i32 : i32
  %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32>
  %3 = tt.splat %1 : (i32) -> tensor<1024xi32>
  %4 = arith.addi %3, %2 : tensor<1024xi32>
  %5 = tt.splat %arg3 : (i32) -> tensor<1024xi32>
  %6 = arith.cmpi slt, %4, %5 : tensor<1024xi32>
  %7 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
  %8 = tt.addptr %7, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
  %9 = tt.load %8, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32>
  %10 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
  %11 = tt.addptr %10, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
  %12 = tt.load %11, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32>
  %13 = arith.addf %9, %12 : tensor<1024xf32>
  %14 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
  %15 = tt.addptr %14, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
  tt.store %15, %13, %6 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32>
  tt.return
}

// -----// IR Dump After Inliner (inline) //----- //
module {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32>
    %3 = tt.splat %1 : (i32) -> tensor<1024xi32>
    %4 = arith.addi %3, %2 : tensor<1024xi32>
    %5 = tt.splat %arg3 : (i32) -> tensor<1024xi32>
    %6 = arith.cmpi slt, %4, %5 : tensor<1024xi32>
    %7 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
    %8 = tt.addptr %7, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
    %9 = tt.load %8, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32>
    %10 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
    %11 = tt.addptr %10, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
    %12 = tt.load %11, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32>
    %13 = arith.addf %9, %12 : tensor<1024xf32>
    %14 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
    %15 = tt.addptr %14, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
    tt.store %15, %13, %6 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32>
    tt.return
  }
}


// -----// IR Dump After Canonicalizer (canonicalize) //----- //
tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
  %c1024_i32 = arith.constant 1024 : i32
  %0 = tt.get_program_id x : i32
  %1 = arith.muli %0, %c1024_i32 : i32
  %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32>
  %3 = tt.splat %1 : (i32) -> tensor<1024xi32>
  %4 = arith.addi %3, %2 : tensor<1024xi32>
  %5 = tt.splat %arg3 : (i32) -> tensor<1024xi32>
  %6 = arith.cmpi slt, %4, %5 : tensor<1024xi32>
  %7 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
  %8 = tt.addptr %7, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
  %9 = tt.load %8, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32>
  %10 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
  %11 = tt.addptr %10, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
  %12 = tt.load %11, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32>
  %13 = arith.addf %9, %12 : tensor<1024xf32>
  %14 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
  %15 = tt.addptr %14, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
  tt.store %15, %13, %6 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32>
  tt.return
}

// -----// IR Dump After Inliner (inline) //----- //
module {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32>
    %3 = tt.splat %1 : (i32) -> tensor<1024xi32>
    %4 = arith.addi %3, %2 : tensor<1024xi32>
    %5 = tt.splat %arg3 : (i32) -> tensor<1024xi32>
    %6 = arith.cmpi slt, %4, %5 : tensor<1024xi32>
    %7 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
    %8 = tt.addptr %7, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
    %9 = tt.load %8, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32>
    %10 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
    %11 = tt.addptr %10, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
    %12 = tt.load %11, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32>
    %13 = arith.addf %9, %12 : tensor<1024xf32>
    %14 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
    %15 = tt.addptr %14, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
    tt.store %15, %13, %6 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32>
    tt.return
  }
}


// -----// IR Dump After TritonCombineOps (triton-combine) //----- //
module {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32>
    %3 = tt.splat %1 : (i32) -> tensor<1024xi32>
    %4 = arith.addi %3, %2 : tensor<1024xi32>
    %5 = tt.splat %arg3 : (i32) -> tensor<1024xi32>
    %6 = arith.cmpi slt, %4, %5 : tensor<1024xi32>
    %7 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
    %8 = tt.addptr %7, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
    %9 = tt.load %8, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32>
    %10 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
    %11 = tt.addptr %10, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
    %12 = tt.load %11, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32>
    %13 = arith.addf %9, %12 : tensor<1024xf32>
    %14 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
    %15 = tt.addptr %14, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
    tt.store %15, %13, %6 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32>
    tt.return
  }
}


// -----// IR Dump After Canonicalizer (canonicalize) //----- //
module {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32>
    %3 = tt.splat %1 : (i32) -> tensor<1024xi32>
    %4 = arith.addi %3, %2 : tensor<1024xi32>
    %5 = tt.splat %arg3 : (i32) -> tensor<1024xi32>
    %6 = arith.cmpi slt, %4, %5 : tensor<1024xi32>
    %7 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
    %8 = tt.addptr %7, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
    %9 = tt.load %8, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32>
    %10 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
    %11 = tt.addptr %10, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
    %12 = tt.load %11, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32>
    %13 = arith.addf %9, %12 : tensor<1024xf32>
    %14 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
    %15 = tt.addptr %14, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
    tt.store %15, %13, %6 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32>
    tt.return
  }
}


// -----// IR Dump After CSE (cse) //----- //
module {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32>
    %3 = tt.splat %1 : (i32) -> tensor<1024xi32>
    %4 = arith.addi %3, %2 : tensor<1024xi32>
    %5 = tt.splat %arg3 : (i32) -> tensor<1024xi32>
    %6 = arith.cmpi slt, %4, %5 : tensor<1024xi32>
    %7 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
    %8 = tt.addptr %7, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
    %9 = tt.load %8, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32>
    %10 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
    %11 = tt.addptr %10, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
    %12 = tt.load %11, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32>
    %13 = arith.addf %9, %12 : tensor<1024xf32>
    %14 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
    %15 = tt.addptr %14, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
    tt.store %15, %13, %6 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32>
    tt.return
  }
}


// -----// IR Dump After LoopInvariantCodeMotion (loop-invariant-code-motion) //----- //
module {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32>
    %3 = tt.splat %1 : (i32) -> tensor<1024xi32>
    %4 = arith.addi %3, %2 : tensor<1024xi32>
    %5 = tt.splat %arg3 : (i32) -> tensor<1024xi32>
    %6 = arith.cmpi slt, %4, %5 : tensor<1024xi32>
    %7 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
    %8 = tt.addptr %7, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
    %9 = tt.load %8, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32>
    %10 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
    %11 = tt.addptr %10, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
    %12 = tt.load %11, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32>
    %13 = arith.addf %9, %12 : tensor<1024xf32>
    %14 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
    %15 = tt.addptr %14, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
    tt.store %15, %13, %6 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32>
    tt.return
  }
}


// -----// IR Dump After SymbolDCE (symbol-dce) //----- //
module {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32>
    %3 = tt.splat %1 : (i32) -> tensor<1024xi32>
    %4 = arith.addi %3, %2 : tensor<1024xi32>
    %5 = tt.splat %arg3 : (i32) -> tensor<1024xi32>
    %6 = arith.cmpi slt, %4, %5 : tensor<1024xi32>
    %7 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
    %8 = tt.addptr %7, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
    %9 = tt.load %8, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32>
    %10 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
    %11 = tt.addptr %10, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
    %12 = tt.load %11, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32>
    %13 = arith.addf %9, %12 : tensor<1024xf32>
    %14 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>>
    %15 = tt.addptr %14, %4 : tensor<1024x!tt.ptr<f32, 1>>, tensor<1024xi32>
    tt.store %15, %13, %6 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32>
    tt.return
  }
}


// -----// IR Dump After ConvertTritonToTritonGPU (convert-triton-to-tritongpu) //----- //
#blocked = #triton_gpu.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [4], order = [0], CTAsPerCGA = [1], CTASplitNum = [1], CTAOrder = [0]}>
module attributes {"triton_gpu.compute-capability" = 80 : i32, "triton_gpu.num-ctas" = 1 : i32, "triton_gpu.num-warps" = 4 : i32, "triton_gpu.threads-per-warp" = 32 : i32} {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %3 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %4 = arith.addi %3, %2 : tensor<1024xi32, #blocked>
    %5 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %6 = arith.cmpi slt, %4, %5 : tensor<1024xi32, #blocked>
    %7 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %8 = tt.addptr %7, %4 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %9 = tt.load %8, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %10 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %11 = tt.addptr %10, %4 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %12 = tt.load %11, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %13 = arith.addf %9, %12 : tensor<1024xf32, #blocked>
    %14 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %15 = tt.addptr %14, %4 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    tt.store %15, %13, %6 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32, #blocked>
    tt.return
  }
}


// -----// IR Dump After TritonGPUCoalesce (tritongpu-coalesce) //----- //
#blocked = #triton_gpu.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [4], order = [0], CTAsPerCGA = [1], CTASplitNum = [1], CTAOrder = [0]}>
#blocked1 = #triton_gpu.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0], CTAsPerCGA = [1], CTASplitNum = [1], CTAOrder = [0]}>
module attributes {"triton_gpu.compute-capability" = 80 : i32, "triton_gpu.num-ctas" = 1 : i32, "triton_gpu.num-warps" = 4 : i32, "triton_gpu.threads-per-warp" = 32 : i32} {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %3 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %4 = arith.addi %3, %2 : tensor<1024xi32, #blocked>
    %5 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %6 = arith.cmpi slt, %4, %5 : tensor<1024xi32, #blocked>
    %7 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %8 = tt.addptr %7, %4 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %9 = triton_gpu.convert_layout %8 : (tensor<1024x!tt.ptr<f32, 1>, #blocked>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked1>
    %10 = triton_gpu.convert_layout %6 : (tensor<1024xi1, #blocked>) -> tensor<1024xi1, #blocked1>
    %11 = tt.load %9, %10 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked1>
    %12 = triton_gpu.convert_layout %11 : (tensor<1024xf32, #blocked1>) -> tensor<1024xf32, #blocked>
    %13 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %14 = tt.addptr %13, %4 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %15 = triton_gpu.convert_layout %14 : (tensor<1024x!tt.ptr<f32, 1>, #blocked>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked1>
    %16 = triton_gpu.convert_layout %6 : (tensor<1024xi1, #blocked>) -> tensor<1024xi1, #blocked1>
    %17 = tt.load %15, %16 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked1>
    %18 = triton_gpu.convert_layout %17 : (tensor<1024xf32, #blocked1>) -> tensor<1024xf32, #blocked>
    %19 = arith.addf %12, %18 : tensor<1024xf32, #blocked>
    %20 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %21 = tt.addptr %20, %4 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %22 = triton_gpu.convert_layout %21 : (tensor<1024x!tt.ptr<f32, 1>, #blocked>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked1>
    %23 = triton_gpu.convert_layout %19 : (tensor<1024xf32, #blocked>) -> tensor<1024xf32, #blocked1>
    %24 = triton_gpu.convert_layout %6 : (tensor<1024xi1, #blocked>) -> tensor<1024xi1, #blocked1>
    tt.store %22, %23, %24 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32, #blocked1>
    tt.return
  }
}


// -----// IR Dump After TritonGPURemoveLayoutConversions (tritongpu-remove-layout-conversions) //----- //
#blocked = #triton_gpu.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0], CTAsPerCGA = [1], CTASplitNum = [1], CTAOrder = [0]}>
module attributes {"triton_gpu.compute-capability" = 80 : i32, "triton_gpu.num-ctas" = 1 : i32, "triton_gpu.num-warps" = 4 : i32, "triton_gpu.threads-per-warp" = 32 : i32} {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %3 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %4 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %5 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %6 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %7 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %8 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %9 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %10 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %11 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %12 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %13 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %14 = arith.addi %8, %2 : tensor<1024xi32, #blocked>
    %15 = arith.addi %9, %3 : tensor<1024xi32, #blocked>
    %16 = arith.addi %10, %4 : tensor<1024xi32, #blocked>
    %17 = arith.addi %11, %5 : tensor<1024xi32, #blocked>
    %18 = arith.addi %12, %6 : tensor<1024xi32, #blocked>
    %19 = arith.addi %13, %7 : tensor<1024xi32, #blocked>
    %20 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %21 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %22 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %23 = arith.cmpi slt, %15, %20 : tensor<1024xi32, #blocked>
    %24 = arith.cmpi slt, %17, %21 : tensor<1024xi32, #blocked>
    %25 = arith.cmpi slt, %19, %22 : tensor<1024xi32, #blocked>
    %26 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %27 = tt.addptr %26, %14 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %28 = tt.load %27, %23 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %29 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %30 = tt.addptr %29, %16 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %31 = tt.load %30, %24 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %32 = arith.addf %28, %31 : tensor<1024xf32, #blocked>
    %33 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %34 = tt.addptr %33, %18 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    tt.store %34, %32, %25 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32, #blocked>
    tt.return
  }
}


// -----// IR Dump After TritonGPUAccelerateMatmul (tritongpu-accelerate-matmul) //----- //
#blocked = #triton_gpu.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0], CTAsPerCGA = [1], CTASplitNum = [1], CTAOrder = [0]}>
module attributes {"triton_gpu.compute-capability" = 80 : i32, "triton_gpu.num-ctas" = 1 : i32, "triton_gpu.num-warps" = 4 : i32, "triton_gpu.threads-per-warp" = 32 : i32} {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %3 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %4 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %5 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %6 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %7 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %8 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %9 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %10 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %11 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %12 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %13 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %14 = arith.addi %8, %2 : tensor<1024xi32, #blocked>
    %15 = arith.addi %9, %3 : tensor<1024xi32, #blocked>
    %16 = arith.addi %10, %4 : tensor<1024xi32, #blocked>
    %17 = arith.addi %11, %5 : tensor<1024xi32, #blocked>
    %18 = arith.addi %12, %6 : tensor<1024xi32, #blocked>
    %19 = arith.addi %13, %7 : tensor<1024xi32, #blocked>
    %20 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %21 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %22 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %23 = arith.cmpi slt, %15, %20 : tensor<1024xi32, #blocked>
    %24 = arith.cmpi slt, %17, %21 : tensor<1024xi32, #blocked>
    %25 = arith.cmpi slt, %19, %22 : tensor<1024xi32, #blocked>
    %26 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %27 = tt.addptr %26, %14 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %28 = tt.load %27, %23 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %29 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %30 = tt.addptr %29, %16 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %31 = tt.load %30, %24 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %32 = arith.addf %28, %31 : tensor<1024xf32, #blocked>
    %33 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %34 = tt.addptr %33, %18 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    tt.store %34, %32, %25 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32, #blocked>
    tt.return
  }
}


// -----// IR Dump After TritonGPURemoveLayoutConversions (tritongpu-remove-layout-conversions) //----- //
#blocked = #triton_gpu.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0], CTAsPerCGA = [1], CTASplitNum = [1], CTAOrder = [0]}>
module attributes {"triton_gpu.compute-capability" = 80 : i32, "triton_gpu.num-ctas" = 1 : i32, "triton_gpu.num-warps" = 4 : i32, "triton_gpu.threads-per-warp" = 32 : i32} {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %3 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %4 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %5 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %6 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %7 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %8 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %9 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %10 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %11 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %12 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %13 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %14 = arith.addi %8, %2 : tensor<1024xi32, #blocked>
    %15 = arith.addi %9, %3 : tensor<1024xi32, #blocked>
    %16 = arith.addi %10, %4 : tensor<1024xi32, #blocked>
    %17 = arith.addi %11, %5 : tensor<1024xi32, #blocked>
    %18 = arith.addi %12, %6 : tensor<1024xi32, #blocked>
    %19 = arith.addi %13, %7 : tensor<1024xi32, #blocked>
    %20 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %21 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %22 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %23 = arith.cmpi slt, %15, %20 : tensor<1024xi32, #blocked>
    %24 = arith.cmpi slt, %17, %21 : tensor<1024xi32, #blocked>
    %25 = arith.cmpi slt, %19, %22 : tensor<1024xi32, #blocked>
    %26 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %27 = tt.addptr %26, %14 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %28 = tt.load %27, %23 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %29 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %30 = tt.addptr %29, %16 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %31 = tt.load %30, %24 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %32 = arith.addf %28, %31 : tensor<1024xf32, #blocked>
    %33 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %34 = tt.addptr %33, %18 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    tt.store %34, %32, %25 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32, #blocked>
    tt.return
  }
}


// -----// IR Dump After TritonGPUOptimizeDotOperands (tritongpu-optimize-dot-operands) //----- //
#blocked = #triton_gpu.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0], CTAsPerCGA = [1], CTASplitNum = [1], CTAOrder = [0]}>
module attributes {"triton_gpu.compute-capability" = 80 : i32, "triton_gpu.num-ctas" = 1 : i32, "triton_gpu.num-warps" = 4 : i32, "triton_gpu.threads-per-warp" = 32 : i32} {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %3 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %4 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %5 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %6 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %7 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %8 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %9 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %10 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %11 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %12 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %13 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %14 = arith.addi %8, %2 : tensor<1024xi32, #blocked>
    %15 = arith.addi %9, %3 : tensor<1024xi32, #blocked>
    %16 = arith.addi %10, %4 : tensor<1024xi32, #blocked>
    %17 = arith.addi %11, %5 : tensor<1024xi32, #blocked>
    %18 = arith.addi %12, %6 : tensor<1024xi32, #blocked>
    %19 = arith.addi %13, %7 : tensor<1024xi32, #blocked>
    %20 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %21 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %22 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %23 = arith.cmpi slt, %15, %20 : tensor<1024xi32, #blocked>
    %24 = arith.cmpi slt, %17, %21 : tensor<1024xi32, #blocked>
    %25 = arith.cmpi slt, %19, %22 : tensor<1024xi32, #blocked>
    %26 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %27 = tt.addptr %26, %14 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %28 = tt.load %27, %23 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %29 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %30 = tt.addptr %29, %16 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %31 = tt.load %30, %24 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %32 = arith.addf %28, %31 : tensor<1024xf32, #blocked>
    %33 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %34 = tt.addptr %33, %18 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    tt.store %34, %32, %25 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32, #blocked>
    tt.return
  }
}


// -----// IR Dump After TritonGPUPipeline (tritongpu-pipeline) //----- //
#blocked = #triton_gpu.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0], CTAsPerCGA = [1], CTASplitNum = [1], CTAOrder = [0]}>
module attributes {"triton_gpu.compute-capability" = 80 : i32, "triton_gpu.num-ctas" = 1 : i32, "triton_gpu.num-warps" = 4 : i32, "triton_gpu.threads-per-warp" = 32 : i32} {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %3 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %4 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %5 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %6 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %7 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %8 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %9 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %10 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %11 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %12 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %13 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %14 = arith.addi %8, %2 : tensor<1024xi32, #blocked>
    %15 = arith.addi %9, %3 : tensor<1024xi32, #blocked>
    %16 = arith.addi %10, %4 : tensor<1024xi32, #blocked>
    %17 = arith.addi %11, %5 : tensor<1024xi32, #blocked>
    %18 = arith.addi %12, %6 : tensor<1024xi32, #blocked>
    %19 = arith.addi %13, %7 : tensor<1024xi32, #blocked>
    %20 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %21 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %22 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %23 = arith.cmpi slt, %15, %20 : tensor<1024xi32, #blocked>
    %24 = arith.cmpi slt, %17, %21 : tensor<1024xi32, #blocked>
    %25 = arith.cmpi slt, %19, %22 : tensor<1024xi32, #blocked>
    %26 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %27 = tt.addptr %26, %14 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %28 = tt.load %27, %23 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %29 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %30 = tt.addptr %29, %16 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %31 = tt.load %30, %24 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %32 = arith.addf %28, %31 : tensor<1024xf32, #blocked>
    %33 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %34 = tt.addptr %33, %18 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    tt.store %34, %32, %25 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32, #blocked>
    tt.return
  }
}


// -----// IR Dump After TritonGPUPrefetch (tritongpu-prefetch) //----- //
#blocked = #triton_gpu.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0], CTAsPerCGA = [1], CTASplitNum = [1], CTAOrder = [0]}>
module attributes {"triton_gpu.compute-capability" = 80 : i32, "triton_gpu.num-ctas" = 1 : i32, "triton_gpu.num-warps" = 4 : i32, "triton_gpu.threads-per-warp" = 32 : i32} {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %3 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %4 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %5 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %6 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %7 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %8 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %9 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %10 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %11 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %12 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %13 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %14 = arith.addi %8, %2 : tensor<1024xi32, #blocked>
    %15 = arith.addi %9, %3 : tensor<1024xi32, #blocked>
    %16 = arith.addi %10, %4 : tensor<1024xi32, #blocked>
    %17 = arith.addi %11, %5 : tensor<1024xi32, #blocked>
    %18 = arith.addi %12, %6 : tensor<1024xi32, #blocked>
    %19 = arith.addi %13, %7 : tensor<1024xi32, #blocked>
    %20 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %21 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %22 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %23 = arith.cmpi slt, %15, %20 : tensor<1024xi32, #blocked>
    %24 = arith.cmpi slt, %17, %21 : tensor<1024xi32, #blocked>
    %25 = arith.cmpi slt, %19, %22 : tensor<1024xi32, #blocked>
    %26 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %27 = tt.addptr %26, %14 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %28 = tt.load %27, %23 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %29 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %30 = tt.addptr %29, %16 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %31 = tt.load %30, %24 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %32 = arith.addf %28, %31 : tensor<1024xf32, #blocked>
    %33 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %34 = tt.addptr %33, %18 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    tt.store %34, %32, %25 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32, #blocked>
    tt.return
  }
}


// -----// IR Dump After TritonGPUOptimizeDotOperands (tritongpu-optimize-dot-operands) //----- //
#blocked = #triton_gpu.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0], CTAsPerCGA = [1], CTASplitNum = [1], CTAOrder = [0]}>
module attributes {"triton_gpu.compute-capability" = 80 : i32, "triton_gpu.num-ctas" = 1 : i32, "triton_gpu.num-warps" = 4 : i32, "triton_gpu.threads-per-warp" = 32 : i32} {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %3 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %4 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %5 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %6 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %7 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %8 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %9 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %10 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %11 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %12 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %13 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %14 = arith.addi %8, %2 : tensor<1024xi32, #blocked>
    %15 = arith.addi %9, %3 : tensor<1024xi32, #blocked>
    %16 = arith.addi %10, %4 : tensor<1024xi32, #blocked>
    %17 = arith.addi %11, %5 : tensor<1024xi32, #blocked>
    %18 = arith.addi %12, %6 : tensor<1024xi32, #blocked>
    %19 = arith.addi %13, %7 : tensor<1024xi32, #blocked>
    %20 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %21 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %22 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %23 = arith.cmpi slt, %15, %20 : tensor<1024xi32, #blocked>
    %24 = arith.cmpi slt, %17, %21 : tensor<1024xi32, #blocked>
    %25 = arith.cmpi slt, %19, %22 : tensor<1024xi32, #blocked>
    %26 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %27 = tt.addptr %26, %14 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %28 = tt.load %27, %23 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %29 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %30 = tt.addptr %29, %16 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %31 = tt.load %30, %24 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %32 = arith.addf %28, %31 : tensor<1024xf32, #blocked>
    %33 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %34 = tt.addptr %33, %18 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    tt.store %34, %32, %25 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32, #blocked>
    tt.return
  }
}


// -----// IR Dump After TritonGPURemoveLayoutConversions (tritongpu-remove-layout-conversions) //----- //
#blocked = #triton_gpu.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0], CTAsPerCGA = [1], CTASplitNum = [1], CTAOrder = [0]}>
module attributes {"triton_gpu.compute-capability" = 80 : i32, "triton_gpu.num-ctas" = 1 : i32, "triton_gpu.num-warps" = 4 : i32, "triton_gpu.threads-per-warp" = 32 : i32} {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %3 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %4 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %5 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %6 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %7 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %8 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %9 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %10 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %11 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %12 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %13 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %14 = arith.addi %8, %2 : tensor<1024xi32, #blocked>
    %15 = arith.addi %9, %3 : tensor<1024xi32, #blocked>
    %16 = arith.addi %10, %4 : tensor<1024xi32, #blocked>
    %17 = arith.addi %11, %5 : tensor<1024xi32, #blocked>
    %18 = arith.addi %12, %6 : tensor<1024xi32, #blocked>
    %19 = arith.addi %13, %7 : tensor<1024xi32, #blocked>
    %20 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %21 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %22 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %23 = arith.cmpi slt, %15, %20 : tensor<1024xi32, #blocked>
    %24 = arith.cmpi slt, %17, %21 : tensor<1024xi32, #blocked>
    %25 = arith.cmpi slt, %19, %22 : tensor<1024xi32, #blocked>
    %26 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %27 = tt.addptr %26, %14 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %28 = tt.load %27, %23 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %29 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %30 = tt.addptr %29, %16 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %31 = tt.load %30, %24 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %32 = arith.addf %28, %31 : tensor<1024xf32, #blocked>
    %33 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %34 = tt.addptr %33, %18 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    tt.store %34, %32, %25 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32, #blocked>
    tt.return
  }
}


// -----// IR Dump After TritonGPUDecomposeConversions (tritongpu-decompose-conversions) //----- //
#blocked = #triton_gpu.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0], CTAsPerCGA = [1], CTASplitNum = [1], CTAOrder = [0]}>
module attributes {"triton_gpu.compute-capability" = 80 : i32, "triton_gpu.num-ctas" = 1 : i32, "triton_gpu.num-warps" = 4 : i32, "triton_gpu.threads-per-warp" = 32 : i32} {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %3 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %4 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %5 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %6 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %7 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %8 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %9 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %10 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %11 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %12 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %13 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %14 = arith.addi %8, %2 : tensor<1024xi32, #blocked>
    %15 = arith.addi %9, %3 : tensor<1024xi32, #blocked>
    %16 = arith.addi %10, %4 : tensor<1024xi32, #blocked>
    %17 = arith.addi %11, %5 : tensor<1024xi32, #blocked>
    %18 = arith.addi %12, %6 : tensor<1024xi32, #blocked>
    %19 = arith.addi %13, %7 : tensor<1024xi32, #blocked>
    %20 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %21 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %22 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %23 = arith.cmpi slt, %15, %20 : tensor<1024xi32, #blocked>
    %24 = arith.cmpi slt, %17, %21 : tensor<1024xi32, #blocked>
    %25 = arith.cmpi slt, %19, %22 : tensor<1024xi32, #blocked>
    %26 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %27 = tt.addptr %26, %14 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %28 = tt.load %27, %23 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %29 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %30 = tt.addptr %29, %16 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %31 = tt.load %30, %24 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %32 = arith.addf %28, %31 : tensor<1024xf32, #blocked>
    %33 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %34 = tt.addptr %33, %18 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    tt.store %34, %32, %25 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32, #blocked>
    tt.return
  }
}


// -----// IR Dump After TritonGPUReorderInstructions (tritongpu-reorder-instructions) //----- //
#blocked = #triton_gpu.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0], CTAsPerCGA = [1], CTASplitNum = [1], CTAOrder = [0]}>
module attributes {"triton_gpu.compute-capability" = 80 : i32, "triton_gpu.num-ctas" = 1 : i32, "triton_gpu.num-warps" = 4 : i32, "triton_gpu.threads-per-warp" = 32 : i32} {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %3 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %4 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %5 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %6 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %7 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %8 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %9 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %10 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %11 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %12 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %13 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %14 = arith.addi %8, %2 : tensor<1024xi32, #blocked>
    %15 = arith.addi %9, %3 : tensor<1024xi32, #blocked>
    %16 = arith.addi %10, %4 : tensor<1024xi32, #blocked>
    %17 = arith.addi %11, %5 : tensor<1024xi32, #blocked>
    %18 = arith.addi %12, %6 : tensor<1024xi32, #blocked>
    %19 = arith.addi %13, %7 : tensor<1024xi32, #blocked>
    %20 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %21 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %22 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %23 = arith.cmpi slt, %15, %20 : tensor<1024xi32, #blocked>
    %24 = arith.cmpi slt, %17, %21 : tensor<1024xi32, #blocked>
    %25 = arith.cmpi slt, %19, %22 : tensor<1024xi32, #blocked>
    %26 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %27 = tt.addptr %26, %14 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %28 = tt.load %27, %23 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %29 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %30 = tt.addptr %29, %16 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %31 = tt.load %30, %24 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %32 = arith.addf %28, %31 : tensor<1024xf32, #blocked>
    %33 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %34 = tt.addptr %33, %18 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    tt.store %34, %32, %25 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32, #blocked>
    tt.return
  }
}


// -----// IR Dump After CSE (cse) //----- //
#blocked = #triton_gpu.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0], CTAsPerCGA = [1], CTASplitNum = [1], CTAOrder = [0]}>
module attributes {"triton_gpu.compute-capability" = 80 : i32, "triton_gpu.num-ctas" = 1 : i32, "triton_gpu.num-warps" = 4 : i32, "triton_gpu.threads-per-warp" = 32 : i32} {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %3 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %4 = arith.addi %3, %2 : tensor<1024xi32, #blocked>
    %5 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %6 = arith.cmpi slt, %4, %5 : tensor<1024xi32, #blocked>
    %7 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %8 = tt.addptr %7, %4 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %9 = tt.load %8, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %10 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %11 = tt.addptr %10, %4 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %12 = tt.load %11, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %13 = arith.addf %9, %12 : tensor<1024xf32, #blocked>
    %14 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %15 = tt.addptr %14, %4 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    tt.store %15, %13, %6 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32, #blocked>
    tt.return
  }
}


// -----// IR Dump After SymbolDCE (symbol-dce) //----- //
#blocked = #triton_gpu.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0], CTAsPerCGA = [1], CTASplitNum = [1], CTAOrder = [0]}>
module attributes {"triton_gpu.compute-capability" = 80 : i32, "triton_gpu.num-ctas" = 1 : i32, "triton_gpu.num-warps" = 4 : i32, "triton_gpu.threads-per-warp" = 32 : i32} {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %3 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %4 = arith.addi %3, %2 : tensor<1024xi32, #blocked>
    %5 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %6 = arith.cmpi slt, %4, %5 : tensor<1024xi32, #blocked>
    %7 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %8 = tt.addptr %7, %4 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %9 = tt.load %8, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %10 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %11 = tt.addptr %10, %4 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %12 = tt.load %11, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %13 = arith.addf %9, %12 : tensor<1024xf32, #blocked>
    %14 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %15 = tt.addptr %14, %4 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    tt.store %15, %13, %6 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32, #blocked>
    tt.return
  }
}


// -----// IR Dump After SCFToControlFlow (convert-scf-to-cf) //----- //
#blocked = #triton_gpu.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0], CTAsPerCGA = [1], CTASplitNum = [1], CTAOrder = [0]}>
module attributes {"triton_gpu.compute-capability" = 80 : i32, "triton_gpu.num-ctas" = 1 : i32, "triton_gpu.num-warps" = 4 : i32, "triton_gpu.threads-per-warp" = 32 : i32} {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %3 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %4 = arith.addi %3, %2 : tensor<1024xi32, #blocked>
    %5 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %6 = arith.cmpi slt, %4, %5 : tensor<1024xi32, #blocked>
    %7 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %8 = tt.addptr %7, %4 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %9 = tt.load %8, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %10 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %11 = tt.addptr %10, %4 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %12 = tt.load %11, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %13 = arith.addf %9, %12 : tensor<1024xf32, #blocked>
    %14 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %15 = tt.addptr %14, %4 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    tt.store %15, %13, %6 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32, #blocked>
    tt.return
  }
}


// -----// IR Dump After ConvertIndexToLLVMPass (convert-index-to-llvm) //----- //
#blocked = #triton_gpu.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0], CTAsPerCGA = [1], CTASplitNum = [1], CTAOrder = [0]}>
module attributes {"triton_gpu.compute-capability" = 80 : i32, "triton_gpu.num-ctas" = 1 : i32, "triton_gpu.num-warps" = 4 : i32, "triton_gpu.threads-per-warp" = 32 : i32} {
  tt.func public @add_kernel_0d1d2d3de(%arg0: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32, 1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %c1024_i32 : i32
    %2 = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked>
    %3 = tt.splat %1 : (i32) -> tensor<1024xi32, #blocked>
    %4 = arith.addi %3, %2 : tensor<1024xi32, #blocked>
    %5 = tt.splat %arg3 : (i32) -> tensor<1024xi32, #blocked>
    %6 = arith.cmpi slt, %4, %5 : tensor<1024xi32, #blocked>
    %7 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %8 = tt.addptr %7, %4 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %9 = tt.load %8, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %10 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %11 = tt.addptr %10, %4 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    %12 = tt.load %11, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<1024xf32, #blocked>
    %13 = arith.addf %9, %12 : tensor<1024xf32, #blocked>
    %14 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<1024x!tt.ptr<f32, 1>, #blocked>
    %15 = tt.addptr %14, %4 : tensor<1024x!tt.ptr<f32, 1>, #blocked>, tensor<1024xi32, #blocked>
    tt.store %15, %13, %6 {cache = 1 : i32, evict = 1 : i32} : tensor<1024xf32, #blocked>
    tt.return
  }
}


// -----// IR Dump After ConvertTritonGPUToLLVM (convert-triton-gpu-to-llvm) //----- //
module attributes {"triton_gpu.compute-capability" = 80 : i32, "triton_gpu.num-ctas" = 1 : i32, "triton_gpu.num-warps" = 4 : i32, triton_gpu.shared = 0 : i32, "triton_gpu.threads-per-warp" = 32 : i32} {
  llvm.func @add_kernel_0d1d2d3de(%arg0: !llvm.ptr<1> {tt.divisibility = 16 : i32}, %arg1: !llvm.ptr<1> {tt.divisibility = 16 : i32}, %arg2: !llvm.ptr<1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {genx.intel_reqd_sub_group_size = [32 : i32], genx.kernel = 1 : i32, genx.max_work_group_size = [128 : i32, 1 : i32, 1 : i32], noinline = false, sym_visibility = "public", "triton_gpu.num-tma-load" = 0 : i32, "triton_gpu.num-tma-store" = 0 : i32} {
    %0 = genx.workitem.id.x : i32
    %1 = llvm.mlir.constant(32 : i32) : i32
    %2 = llvm.urem %0, %1  : i32
    %3 = llvm.udiv %0, %1  : i32
    %4 = llvm.mlir.constant(4 : i32) : i32
    %5 = llvm.urem %3, %4  : i32
    %6 = llvm.udiv %3, %4  : i32
    %7 = llvm.mlir.constant(32 : i32) : i32
    %8 = llvm.urem %2, %7  : i32
    %9 = llvm.udiv %2, %7  : i32
    %10 = llvm.mlir.constant(8 : i32) : i32
    %11 = llvm.urem %5, %10  : i32
    %12 = llvm.mlir.constant(256 : i32) : i32
    %13 = llvm.urem %8, %12  : i32
    %14 = llvm.mlir.constant(32 : i32) : i32
    %15 = llvm.mlir.constant(4 : i32) : i32
    %16 = llvm.mul %11, %14  : i32
    %17 = llvm.add %13, %16  : i32
    %18 = llvm.mul %15, %17  : i32
    %19 = llvm.mlir.constant(0 : i32) : i32
    %20 = llvm.mlir.constant(0 : i32) : i32
    %21 = llvm.mlir.constant(1 : i32) : i32
    %22 = llvm.urem %20, %21  : i32
    %23 = llvm.mlir.constant(1024 : i32) : i32
    %24 = llvm.mul %22, %23  : i32
    %25 = llvm.add %18, %24  : i32
    %26 = llvm.mlir.constant(0 : i32) : i32
    %27 = llvm.add %25, %26  : i32
    %28 = llvm.mlir.constant(1 : i32) : i32
    %29 = llvm.add %25, %28  : i32
    %30 = llvm.mlir.constant(2 : i32) : i32
    %31 = llvm.add %25, %30  : i32
    %32 = llvm.mlir.constant(3 : i32) : i32
    %33 = llvm.add %25, %32  : i32
    %34 = llvm.mlir.constant(512 : i32) : i32
    %35 = llvm.add %25, %34  : i32
    %36 = llvm.mlir.constant(513 : i32) : i32
    %37 = llvm.add %25, %36  : i32
    %38 = llvm.mlir.constant(514 : i32) : i32
    %39 = llvm.add %25, %38  : i32
    %40 = llvm.mlir.constant(515 : i32) : i32
    %41 = llvm.add %25, %40  : i32
    %42 = builtin.unrealized_conversion_cast %arg2 : !llvm.ptr<1> to !tt.ptr<f32, 1>
    %43 = builtin.unrealized_conversion_cast %arg1 : !llvm.ptr<1> to !tt.ptr<f32, 1>
    %44 = builtin.unrealized_conversion_cast %arg0 : !llvm.ptr<1> to !tt.ptr<f32, 1>
    %45 = llvm.mlir.constant(1024 : i32) : i32
    %46 = genx.workgroup.id.x : i32
    %47 = llvm.mul %46, %45  : i32
    %48 = llvm.mlir.constant(0 : index) : i32
    %49 = llvm.add %27, %48  : i32
    %50 = llvm.add %29, %48  : i32
    %51 = llvm.add %31, %48  : i32
    %52 = llvm.add %33, %48  : i32
    %53 = llvm.add %35, %48  : i32
    %54 = llvm.add %37, %48  : i32
    %55 = llvm.add %39, %48  : i32
    %56 = llvm.add %41, %48  : i32
    %57 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>
    %58 = llvm.insertvalue %49, %57[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %59 = llvm.insertvalue %50, %58[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %60 = llvm.insertvalue %51, %59[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %61 = llvm.insertvalue %52, %60[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %62 = llvm.insertvalue %53, %61[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %63 = llvm.insertvalue %54, %62[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %64 = llvm.insertvalue %55, %63[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %65 = llvm.insertvalue %56, %64[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %66 = llvm.bitcast %47 : i32 to i32
    %67 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>
    %68 = llvm.insertvalue %66, %67[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %69 = llvm.insertvalue %66, %68[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %70 = llvm.insertvalue %66, %69[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %71 = llvm.insertvalue %66, %70[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %72 = llvm.insertvalue %66, %71[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %73 = llvm.insertvalue %66, %72[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %74 = llvm.insertvalue %66, %73[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %75 = llvm.insertvalue %66, %74[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %76 = llvm.extractvalue %75[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %77 = llvm.extractvalue %75[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %78 = llvm.extractvalue %75[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %79 = llvm.extractvalue %75[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %80 = llvm.extractvalue %75[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %81 = llvm.extractvalue %75[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %82 = llvm.extractvalue %75[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %83 = llvm.extractvalue %75[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %84 = llvm.extractvalue %65[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %85 = llvm.extractvalue %65[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %86 = llvm.extractvalue %65[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %87 = llvm.extractvalue %65[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %88 = llvm.extractvalue %65[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %89 = llvm.extractvalue %65[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %90 = llvm.extractvalue %65[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %91 = llvm.extractvalue %65[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %92 = llvm.add %76, %84  : i32
    %93 = llvm.add %77, %85  : i32
    %94 = llvm.add %78, %86  : i32
    %95 = llvm.add %79, %87  : i32
    %96 = llvm.add %80, %88  : i32
    %97 = llvm.add %81, %89  : i32
    %98 = llvm.add %82, %90  : i32
    %99 = llvm.add %83, %91  : i32
    %100 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>
    %101 = llvm.insertvalue %92, %100[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %102 = llvm.insertvalue %93, %101[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %103 = llvm.insertvalue %94, %102[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %104 = llvm.insertvalue %95, %103[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %105 = llvm.insertvalue %96, %104[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %106 = llvm.insertvalue %97, %105[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %107 = llvm.insertvalue %98, %106[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %108 = llvm.insertvalue %99, %107[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %109 = llvm.bitcast %arg3 : i32 to i32
    %110 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>
    %111 = llvm.insertvalue %109, %110[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %112 = llvm.insertvalue %109, %111[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %113 = llvm.insertvalue %109, %112[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %114 = llvm.insertvalue %109, %113[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %115 = llvm.insertvalue %109, %114[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %116 = llvm.insertvalue %109, %115[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %117 = llvm.insertvalue %109, %116[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %118 = llvm.insertvalue %109, %117[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %119 = llvm.extractvalue %108[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %120 = llvm.extractvalue %108[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %121 = llvm.extractvalue %108[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %122 = llvm.extractvalue %108[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %123 = llvm.extractvalue %108[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %124 = llvm.extractvalue %108[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %125 = llvm.extractvalue %108[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %126 = llvm.extractvalue %108[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %127 = llvm.extractvalue %118[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %128 = llvm.extractvalue %118[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %129 = llvm.extractvalue %118[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %130 = llvm.extractvalue %118[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %131 = llvm.extractvalue %118[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %132 = llvm.extractvalue %118[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %133 = llvm.extractvalue %118[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %134 = llvm.extractvalue %118[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %135 = llvm.icmp "slt" %119, %127 : i32
    %136 = llvm.icmp "slt" %120, %128 : i32
    %137 = llvm.icmp "slt" %121, %129 : i32
    %138 = llvm.icmp "slt" %122, %130 : i32
    %139 = llvm.icmp "slt" %123, %131 : i32
    %140 = llvm.icmp "slt" %124, %132 : i32
    %141 = llvm.icmp "slt" %125, %133 : i32
    %142 = llvm.icmp "slt" %126, %134 : i32
    %143 = llvm.mlir.undef : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>
    %144 = llvm.insertvalue %135, %143[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %145 = llvm.insertvalue %135, %144[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %146 = llvm.insertvalue %135, %145[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %147 = llvm.insertvalue %135, %146[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %148 = llvm.insertvalue %139, %147[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %149 = llvm.insertvalue %139, %148[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %150 = llvm.insertvalue %139, %149[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %151 = llvm.insertvalue %139, %150[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %152 = llvm.bitcast %arg0 : !llvm.ptr<1> to !llvm.ptr<1>
    %153 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>
    %154 = llvm.insertvalue %152, %153[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %155 = llvm.insertvalue %152, %154[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %156 = llvm.insertvalue %152, %155[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %157 = llvm.insertvalue %152, %156[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %158 = llvm.insertvalue %152, %157[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %159 = llvm.insertvalue %152, %158[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %160 = llvm.insertvalue %152, %159[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %161 = llvm.insertvalue %152, %160[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %162 = llvm.extractvalue %161[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %163 = llvm.extractvalue %161[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %164 = llvm.extractvalue %161[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %165 = llvm.extractvalue %161[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %166 = llvm.extractvalue %161[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %167 = llvm.extractvalue %161[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %168 = llvm.extractvalue %161[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %169 = llvm.extractvalue %161[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %170 = llvm.extractvalue %108[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %171 = llvm.extractvalue %108[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %172 = llvm.extractvalue %108[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %173 = llvm.extractvalue %108[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %174 = llvm.extractvalue %108[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %175 = llvm.extractvalue %108[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %176 = llvm.extractvalue %108[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %177 = llvm.extractvalue %108[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %178 = llvm.getelementptr %162[%170] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %179 = llvm.getelementptr %163[%171] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %180 = llvm.getelementptr %164[%172] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %181 = llvm.getelementptr %165[%173] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %182 = llvm.getelementptr %166[%174] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %183 = llvm.getelementptr %167[%175] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %184 = llvm.getelementptr %168[%176] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %185 = llvm.getelementptr %169[%177] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %186 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>
    %187 = llvm.insertvalue %178, %186[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %188 = llvm.insertvalue %179, %187[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %189 = llvm.insertvalue %180, %188[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %190 = llvm.insertvalue %181, %189[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %191 = llvm.insertvalue %182, %190[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %192 = llvm.insertvalue %183, %191[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %193 = llvm.insertvalue %184, %192[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %194 = llvm.insertvalue %185, %193[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %195 = llvm.extractvalue %194[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %196 = llvm.extractvalue %194[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %197 = llvm.extractvalue %194[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %198 = llvm.extractvalue %194[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %199 = llvm.extractvalue %194[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %200 = llvm.extractvalue %194[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %201 = llvm.extractvalue %194[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %202 = llvm.extractvalue %194[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %203 = llvm.extractvalue %151[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %204 = llvm.extractvalue %151[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %205 = llvm.extractvalue %151[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %206 = llvm.extractvalue %151[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %207 = llvm.extractvalue %151[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %208 = llvm.extractvalue %151[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %209 = llvm.extractvalue %151[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %210 = llvm.extractvalue %151[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %211 = llvm.mlir.undef : vector<4xi32>
    llvm.cond_br %203, ^bb1, ^bb2(%211 : vector<4xi32>)
  ^bb1:  // pred: ^bb0
    %212 = llvm.bitcast %195 : !llvm.ptr<1> to !llvm.ptr<1>
    %213 = llvm.load %212 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb2(%213 : vector<4xi32>)
  ^bb2(%214: vector<4xi32>):  // 2 preds: ^bb0, ^bb1
    %215 = llvm.mlir.constant(0 : i32) : i32
    %216 = llvm.extractelement %214[%215 : i32] : vector<4xi32>
    %217 = llvm.bitcast %216 : i32 to vector<1xf32>
    %218 = llvm.mlir.constant(1 : i32) : i32
    %219 = llvm.extractelement %214[%218 : i32] : vector<4xi32>
    %220 = llvm.bitcast %219 : i32 to vector<1xf32>
    %221 = llvm.mlir.constant(2 : i32) : i32
    %222 = llvm.extractelement %214[%221 : i32] : vector<4xi32>
    %223 = llvm.bitcast %222 : i32 to vector<1xf32>
    %224 = llvm.mlir.constant(3 : i32) : i32
    %225 = llvm.extractelement %214[%224 : i32] : vector<4xi32>
    %226 = llvm.bitcast %225 : i32 to vector<1xf32>
    %227 = llvm.mlir.constant(0 : i32) : i32
    %228 = llvm.extractelement %217[%227 : i32] : vector<1xf32>
    %229 = llvm.mlir.constant(0 : i32) : i32
    %230 = llvm.extractelement %220[%229 : i32] : vector<1xf32>
    %231 = llvm.mlir.constant(0 : i32) : i32
    %232 = llvm.extractelement %223[%231 : i32] : vector<1xf32>
    %233 = llvm.mlir.constant(0 : i32) : i32
    %234 = llvm.extractelement %226[%233 : i32] : vector<1xf32>
    %235 = llvm.mlir.undef : vector<4xi32>
    llvm.cond_br %207, ^bb3, ^bb4(%235 : vector<4xi32>)
  ^bb3:  // pred: ^bb2
    %236 = llvm.bitcast %199 : !llvm.ptr<1> to !llvm.ptr<1>
    %237 = llvm.load %236 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb4(%237 : vector<4xi32>)
  ^bb4(%238: vector<4xi32>):  // 2 preds: ^bb2, ^bb3
    %239 = llvm.mlir.constant(0 : i32) : i32
    %240 = llvm.extractelement %238[%239 : i32] : vector<4xi32>
    %241 = llvm.bitcast %240 : i32 to vector<1xf32>
    %242 = llvm.mlir.constant(1 : i32) : i32
    %243 = llvm.extractelement %238[%242 : i32] : vector<4xi32>
    %244 = llvm.bitcast %243 : i32 to vector<1xf32>
    %245 = llvm.mlir.constant(2 : i32) : i32
    %246 = llvm.extractelement %238[%245 : i32] : vector<4xi32>
    %247 = llvm.bitcast %246 : i32 to vector<1xf32>
    %248 = llvm.mlir.constant(3 : i32) : i32
    %249 = llvm.extractelement %238[%248 : i32] : vector<4xi32>
    %250 = llvm.bitcast %249 : i32 to vector<1xf32>
    %251 = llvm.mlir.constant(0 : i32) : i32
    %252 = llvm.extractelement %241[%251 : i32] : vector<1xf32>
    %253 = llvm.mlir.constant(0 : i32) : i32
    %254 = llvm.extractelement %244[%253 : i32] : vector<1xf32>
    %255 = llvm.mlir.constant(0 : i32) : i32
    %256 = llvm.extractelement %247[%255 : i32] : vector<1xf32>
    %257 = llvm.mlir.constant(0 : i32) : i32
    %258 = llvm.extractelement %250[%257 : i32] : vector<1xf32>
    %259 = llvm.mlir.undef : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>
    %260 = llvm.insertvalue %228, %259[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %261 = llvm.insertvalue %230, %260[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %262 = llvm.insertvalue %232, %261[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %263 = llvm.insertvalue %234, %262[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %264 = llvm.insertvalue %252, %263[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %265 = llvm.insertvalue %254, %264[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %266 = llvm.insertvalue %256, %265[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %267 = llvm.insertvalue %258, %266[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %268 = llvm.bitcast %arg1 : !llvm.ptr<1> to !llvm.ptr<1>
    %269 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>
    %270 = llvm.insertvalue %268, %269[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %271 = llvm.insertvalue %268, %270[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %272 = llvm.insertvalue %268, %271[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %273 = llvm.insertvalue %268, %272[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %274 = llvm.insertvalue %268, %273[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %275 = llvm.insertvalue %268, %274[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %276 = llvm.insertvalue %268, %275[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %277 = llvm.insertvalue %268, %276[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %278 = llvm.extractvalue %277[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %279 = llvm.extractvalue %277[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %280 = llvm.extractvalue %277[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %281 = llvm.extractvalue %277[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %282 = llvm.extractvalue %277[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %283 = llvm.extractvalue %277[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %284 = llvm.extractvalue %277[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %285 = llvm.extractvalue %277[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %286 = llvm.extractvalue %108[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %287 = llvm.extractvalue %108[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %288 = llvm.extractvalue %108[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %289 = llvm.extractvalue %108[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %290 = llvm.extractvalue %108[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %291 = llvm.extractvalue %108[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %292 = llvm.extractvalue %108[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %293 = llvm.extractvalue %108[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %294 = llvm.getelementptr %278[%286] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %295 = llvm.getelementptr %279[%287] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %296 = llvm.getelementptr %280[%288] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %297 = llvm.getelementptr %281[%289] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %298 = llvm.getelementptr %282[%290] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %299 = llvm.getelementptr %283[%291] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %300 = llvm.getelementptr %284[%292] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %301 = llvm.getelementptr %285[%293] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %302 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>
    %303 = llvm.insertvalue %294, %302[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %304 = llvm.insertvalue %295, %303[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %305 = llvm.insertvalue %296, %304[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %306 = llvm.insertvalue %297, %305[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %307 = llvm.insertvalue %298, %306[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %308 = llvm.insertvalue %299, %307[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %309 = llvm.insertvalue %300, %308[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %310 = llvm.insertvalue %301, %309[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %311 = llvm.extractvalue %310[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %312 = llvm.extractvalue %310[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %313 = llvm.extractvalue %310[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %314 = llvm.extractvalue %310[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %315 = llvm.extractvalue %310[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %316 = llvm.extractvalue %310[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %317 = llvm.extractvalue %310[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %318 = llvm.extractvalue %310[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %319 = llvm.extractvalue %151[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %320 = llvm.extractvalue %151[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %321 = llvm.extractvalue %151[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %322 = llvm.extractvalue %151[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %323 = llvm.extractvalue %151[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %324 = llvm.extractvalue %151[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %325 = llvm.extractvalue %151[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %326 = llvm.extractvalue %151[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %327 = llvm.mlir.undef : vector<4xi32>
    llvm.cond_br %319, ^bb5, ^bb6(%327 : vector<4xi32>)
  ^bb5:  // pred: ^bb4
    %328 = llvm.bitcast %311 : !llvm.ptr<1> to !llvm.ptr<1>
    %329 = llvm.load %328 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb6(%329 : vector<4xi32>)
  ^bb6(%330: vector<4xi32>):  // 2 preds: ^bb4, ^bb5
    %331 = llvm.mlir.constant(0 : i32) : i32
    %332 = llvm.extractelement %330[%331 : i32] : vector<4xi32>
    %333 = llvm.bitcast %332 : i32 to vector<1xf32>
    %334 = llvm.mlir.constant(1 : i32) : i32
    %335 = llvm.extractelement %330[%334 : i32] : vector<4xi32>
    %336 = llvm.bitcast %335 : i32 to vector<1xf32>
    %337 = llvm.mlir.constant(2 : i32) : i32
    %338 = llvm.extractelement %330[%337 : i32] : vector<4xi32>
    %339 = llvm.bitcast %338 : i32 to vector<1xf32>
    %340 = llvm.mlir.constant(3 : i32) : i32
    %341 = llvm.extractelement %330[%340 : i32] : vector<4xi32>
    %342 = llvm.bitcast %341 : i32 to vector<1xf32>
    %343 = llvm.mlir.constant(0 : i32) : i32
    %344 = llvm.extractelement %333[%343 : i32] : vector<1xf32>
    %345 = llvm.mlir.constant(0 : i32) : i32
    %346 = llvm.extractelement %336[%345 : i32] : vector<1xf32>
    %347 = llvm.mlir.constant(0 : i32) : i32
    %348 = llvm.extractelement %339[%347 : i32] : vector<1xf32>
    %349 = llvm.mlir.constant(0 : i32) : i32
    %350 = llvm.extractelement %342[%349 : i32] : vector<1xf32>
    %351 = llvm.mlir.undef : vector<4xi32>
    llvm.cond_br %323, ^bb7, ^bb8(%351 : vector<4xi32>)
  ^bb7:  // pred: ^bb6
    %352 = llvm.bitcast %315 : !llvm.ptr<1> to !llvm.ptr<1>
    %353 = llvm.load %352 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb8(%353 : vector<4xi32>)
  ^bb8(%354: vector<4xi32>):  // 2 preds: ^bb6, ^bb7
    %355 = llvm.mlir.constant(0 : i32) : i32
    %356 = llvm.extractelement %354[%355 : i32] : vector<4xi32>
    %357 = llvm.bitcast %356 : i32 to vector<1xf32>
    %358 = llvm.mlir.constant(1 : i32) : i32
    %359 = llvm.extractelement %354[%358 : i32] : vector<4xi32>
    %360 = llvm.bitcast %359 : i32 to vector<1xf32>
    %361 = llvm.mlir.constant(2 : i32) : i32
    %362 = llvm.extractelement %354[%361 : i32] : vector<4xi32>
    %363 = llvm.bitcast %362 : i32 to vector<1xf32>
    %364 = llvm.mlir.constant(3 : i32) : i32
    %365 = llvm.extractelement %354[%364 : i32] : vector<4xi32>
    %366 = llvm.bitcast %365 : i32 to vector<1xf32>
    %367 = llvm.mlir.constant(0 : i32) : i32
    %368 = llvm.extractelement %357[%367 : i32] : vector<1xf32>
    %369 = llvm.mlir.constant(0 : i32) : i32
    %370 = llvm.extractelement %360[%369 : i32] : vector<1xf32>
    %371 = llvm.mlir.constant(0 : i32) : i32
    %372 = llvm.extractelement %363[%371 : i32] : vector<1xf32>
    %373 = llvm.mlir.constant(0 : i32) : i32
    %374 = llvm.extractelement %366[%373 : i32] : vector<1xf32>
    %375 = llvm.mlir.undef : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>
    %376 = llvm.insertvalue %344, %375[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %377 = llvm.insertvalue %346, %376[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %378 = llvm.insertvalue %348, %377[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %379 = llvm.insertvalue %350, %378[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %380 = llvm.insertvalue %368, %379[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %381 = llvm.insertvalue %370, %380[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %382 = llvm.insertvalue %372, %381[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %383 = llvm.insertvalue %374, %382[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %384 = llvm.extractvalue %267[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %385 = llvm.extractvalue %267[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %386 = llvm.extractvalue %267[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %387 = llvm.extractvalue %267[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %388 = llvm.extractvalue %267[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %389 = llvm.extractvalue %267[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %390 = llvm.extractvalue %267[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %391 = llvm.extractvalue %267[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %392 = llvm.extractvalue %383[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %393 = llvm.extractvalue %383[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %394 = llvm.extractvalue %383[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %395 = llvm.extractvalue %383[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %396 = llvm.extractvalue %383[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %397 = llvm.extractvalue %383[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %398 = llvm.extractvalue %383[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %399 = llvm.extractvalue %383[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %400 = llvm.fadd %384, %392  : f32
    %401 = llvm.fadd %385, %393  : f32
    %402 = llvm.fadd %386, %394  : f32
    %403 = llvm.fadd %387, %395  : f32
    %404 = llvm.fadd %388, %396  : f32
    %405 = llvm.fadd %389, %397  : f32
    %406 = llvm.fadd %390, %398  : f32
    %407 = llvm.fadd %391, %399  : f32
    %408 = llvm.mlir.undef : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>
    %409 = llvm.insertvalue %400, %408[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %410 = llvm.insertvalue %401, %409[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %411 = llvm.insertvalue %402, %410[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %412 = llvm.insertvalue %403, %411[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %413 = llvm.insertvalue %404, %412[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %414 = llvm.insertvalue %405, %413[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %415 = llvm.insertvalue %406, %414[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %416 = llvm.insertvalue %407, %415[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %417 = llvm.bitcast %arg2 : !llvm.ptr<1> to !llvm.ptr<1>
    %418 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>
    %419 = llvm.insertvalue %417, %418[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %420 = llvm.insertvalue %417, %419[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %421 = llvm.insertvalue %417, %420[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %422 = llvm.insertvalue %417, %421[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %423 = llvm.insertvalue %417, %422[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %424 = llvm.insertvalue %417, %423[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %425 = llvm.insertvalue %417, %424[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %426 = llvm.insertvalue %417, %425[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %427 = llvm.extractvalue %426[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %428 = llvm.extractvalue %426[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %429 = llvm.extractvalue %426[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %430 = llvm.extractvalue %426[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %431 = llvm.extractvalue %426[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %432 = llvm.extractvalue %426[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %433 = llvm.extractvalue %426[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %434 = llvm.extractvalue %426[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %435 = llvm.extractvalue %108[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %436 = llvm.extractvalue %108[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %437 = llvm.extractvalue %108[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %438 = llvm.extractvalue %108[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %439 = llvm.extractvalue %108[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %440 = llvm.extractvalue %108[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %441 = llvm.extractvalue %108[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %442 = llvm.extractvalue %108[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %443 = llvm.getelementptr %427[%435] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %444 = llvm.getelementptr %428[%436] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %445 = llvm.getelementptr %429[%437] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %446 = llvm.getelementptr %430[%438] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %447 = llvm.getelementptr %431[%439] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %448 = llvm.getelementptr %432[%440] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %449 = llvm.getelementptr %433[%441] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %450 = llvm.getelementptr %434[%442] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %451 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>
    %452 = llvm.insertvalue %443, %451[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %453 = llvm.insertvalue %444, %452[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %454 = llvm.insertvalue %445, %453[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %455 = llvm.insertvalue %446, %454[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %456 = llvm.insertvalue %447, %455[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %457 = llvm.insertvalue %448, %456[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %458 = llvm.insertvalue %449, %457[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %459 = llvm.insertvalue %450, %458[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %460 = llvm.extractvalue %459[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %461 = llvm.extractvalue %459[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %462 = llvm.extractvalue %459[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %463 = llvm.extractvalue %459[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %464 = llvm.extractvalue %459[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %465 = llvm.extractvalue %459[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %466 = llvm.extractvalue %459[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %467 = llvm.extractvalue %459[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %468 = llvm.extractvalue %416[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %469 = llvm.extractvalue %416[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %470 = llvm.extractvalue %416[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %471 = llvm.extractvalue %416[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %472 = llvm.extractvalue %416[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %473 = llvm.extractvalue %416[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %474 = llvm.extractvalue %416[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %475 = llvm.extractvalue %416[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %476 = llvm.extractvalue %151[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %477 = llvm.extractvalue %151[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %478 = llvm.extractvalue %151[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %479 = llvm.extractvalue %151[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %480 = llvm.extractvalue %151[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %481 = llvm.extractvalue %151[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %482 = llvm.extractvalue %151[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %483 = llvm.extractvalue %151[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %484 = llvm.mlir.constant(true) : i1
    %485 = genx.workitem.id.x : i32
    %486 = llvm.mlir.constant(0 : i32) : i32
    %487 = llvm.mlir.constant(32 : i32) : i32
    %488 = llvm.urem %485, %487  : i32
    %489 = llvm.udiv %485, %487  : i32
    %490 = llvm.mlir.constant(4 : i32) : i32
    %491 = llvm.urem %489, %490  : i32
    %492 = llvm.udiv %489, %490  : i32
    %493 = llvm.mlir.constant(32 : i32) : i32
    %494 = llvm.urem %488, %493  : i32
    %495 = llvm.udiv %488, %493  : i32
    %496 = llvm.mlir.undef : vector<1xf32>
    %497 = llvm.bitcast %468 : f32 to f32
    %498 = llvm.mlir.constant(0 : i32) : i32
    %499 = llvm.insertelement %497, %496[%498 : i32] : vector<1xf32>
    %500 = llvm.bitcast %499 : vector<1xf32> to i32
    %501 = llvm.mlir.undef : vector<1xf32>
    %502 = llvm.bitcast %469 : f32 to f32
    %503 = llvm.mlir.constant(0 : i32) : i32
    %504 = llvm.insertelement %502, %501[%503 : i32] : vector<1xf32>
    %505 = llvm.bitcast %504 : vector<1xf32> to i32
    %506 = llvm.mlir.undef : vector<1xf32>
    %507 = llvm.bitcast %470 : f32 to f32
    %508 = llvm.mlir.constant(0 : i32) : i32
    %509 = llvm.insertelement %507, %506[%508 : i32] : vector<1xf32>
    %510 = llvm.bitcast %509 : vector<1xf32> to i32
    %511 = llvm.mlir.undef : vector<1xf32>
    %512 = llvm.bitcast %471 : f32 to f32
    %513 = llvm.mlir.constant(0 : i32) : i32
    %514 = llvm.insertelement %512, %511[%513 : i32] : vector<1xf32>
    %515 = llvm.bitcast %514 : vector<1xf32> to i32
    %516 = llvm.and %484, %476  : i1
    %517 = llvm.mlir.undef : vector<4xi32>
    %518 = llvm.mlir.constant(0 : i32) : i32
    %519 = llvm.insertelement %500, %517[%518 : i32] : vector<4xi32>
    %520 = llvm.mlir.constant(1 : i32) : i32
    %521 = llvm.insertelement %505, %519[%520 : i32] : vector<4xi32>
    %522 = llvm.mlir.constant(2 : i32) : i32
    %523 = llvm.insertelement %510, %521[%522 : i32] : vector<4xi32>
    %524 = llvm.mlir.constant(3 : i32) : i32
    %525 = llvm.insertelement %515, %523[%524 : i32] : vector<4xi32>
    llvm.cond_br %516, ^bb9, ^bb10
  ^bb9:  // pred: ^bb8
    %526 = llvm.bitcast %460 : !llvm.ptr<1> to !llvm.ptr<1>
    llvm.store %525, %526 : vector<4xi32>, !llvm.ptr<1>
    llvm.br ^bb10
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %527 = llvm.mlir.undef : vector<1xf32>
    %528 = llvm.bitcast %472 : f32 to f32
    %529 = llvm.mlir.constant(0 : i32) : i32
    %530 = llvm.insertelement %528, %527[%529 : i32] : vector<1xf32>
    %531 = llvm.bitcast %530 : vector<1xf32> to i32
    %532 = llvm.mlir.undef : vector<1xf32>
    %533 = llvm.bitcast %473 : f32 to f32
    %534 = llvm.mlir.constant(0 : i32) : i32
    %535 = llvm.insertelement %533, %532[%534 : i32] : vector<1xf32>
    %536 = llvm.bitcast %535 : vector<1xf32> to i32
    %537 = llvm.mlir.undef : vector<1xf32>
    %538 = llvm.bitcast %474 : f32 to f32
    %539 = llvm.mlir.constant(0 : i32) : i32
    %540 = llvm.insertelement %538, %537[%539 : i32] : vector<1xf32>
    %541 = llvm.bitcast %540 : vector<1xf32> to i32
    %542 = llvm.mlir.undef : vector<1xf32>
    %543 = llvm.bitcast %475 : f32 to f32
    %544 = llvm.mlir.constant(0 : i32) : i32
    %545 = llvm.insertelement %543, %542[%544 : i32] : vector<1xf32>
    %546 = llvm.bitcast %545 : vector<1xf32> to i32
    %547 = llvm.and %484, %480  : i1
    %548 = llvm.mlir.undef : vector<4xi32>
    %549 = llvm.mlir.constant(0 : i32) : i32
    %550 = llvm.insertelement %531, %548[%549 : i32] : vector<4xi32>
    %551 = llvm.mlir.constant(1 : i32) : i32
    %552 = llvm.insertelement %536, %550[%551 : i32] : vector<4xi32>
    %553 = llvm.mlir.constant(2 : i32) : i32
    %554 = llvm.insertelement %541, %552[%553 : i32] : vector<4xi32>
    %555 = llvm.mlir.constant(3 : i32) : i32
    %556 = llvm.insertelement %546, %554[%555 : i32] : vector<4xi32>
    llvm.cond_br %547, ^bb11, ^bb12
  ^bb11:  // pred: ^bb10
    %557 = llvm.bitcast %464 : !llvm.ptr<1> to !llvm.ptr<1>
    llvm.store %556, %557 : vector<4xi32>, !llvm.ptr<1>
    llvm.br ^bb12
  ^bb12:  // 2 preds: ^bb10, ^bb11
    llvm.return
  }
}


// -----// IR Dump After ArithToLLVMConversionPass (convert-arith-to-llvm) //----- //
module attributes {"triton_gpu.compute-capability" = 80 : i32, "triton_gpu.num-ctas" = 1 : i32, "triton_gpu.num-warps" = 4 : i32, triton_gpu.shared = 0 : i32, "triton_gpu.threads-per-warp" = 32 : i32} {
  llvm.func @add_kernel_0d1d2d3de(%arg0: !llvm.ptr<1> {tt.divisibility = 16 : i32}, %arg1: !llvm.ptr<1> {tt.divisibility = 16 : i32}, %arg2: !llvm.ptr<1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {genx.intel_reqd_sub_group_size = [32 : i32], genx.kernel = 1 : i32, genx.max_work_group_size = [128 : i32, 1 : i32, 1 : i32], noinline = false, sym_visibility = "public", "triton_gpu.num-tma-load" = 0 : i32, "triton_gpu.num-tma-store" = 0 : i32} {
    %0 = genx.workitem.id.x : i32
    %1 = llvm.mlir.constant(32 : i32) : i32
    %2 = llvm.urem %0, %1  : i32
    %3 = llvm.udiv %0, %1  : i32
    %4 = llvm.mlir.constant(4 : i32) : i32
    %5 = llvm.urem %3, %4  : i32
    %6 = llvm.udiv %3, %4  : i32
    %7 = llvm.mlir.constant(32 : i32) : i32
    %8 = llvm.urem %2, %7  : i32
    %9 = llvm.udiv %2, %7  : i32
    %10 = llvm.mlir.constant(8 : i32) : i32
    %11 = llvm.urem %5, %10  : i32
    %12 = llvm.mlir.constant(256 : i32) : i32
    %13 = llvm.urem %8, %12  : i32
    %14 = llvm.mlir.constant(32 : i32) : i32
    %15 = llvm.mlir.constant(4 : i32) : i32
    %16 = llvm.mul %11, %14  : i32
    %17 = llvm.add %13, %16  : i32
    %18 = llvm.mul %15, %17  : i32
    %19 = llvm.mlir.constant(0 : i32) : i32
    %20 = llvm.mlir.constant(0 : i32) : i32
    %21 = llvm.mlir.constant(1 : i32) : i32
    %22 = llvm.urem %20, %21  : i32
    %23 = llvm.mlir.constant(1024 : i32) : i32
    %24 = llvm.mul %22, %23  : i32
    %25 = llvm.add %18, %24  : i32
    %26 = llvm.mlir.constant(0 : i32) : i32
    %27 = llvm.add %25, %26  : i32
    %28 = llvm.mlir.constant(1 : i32) : i32
    %29 = llvm.add %25, %28  : i32
    %30 = llvm.mlir.constant(2 : i32) : i32
    %31 = llvm.add %25, %30  : i32
    %32 = llvm.mlir.constant(3 : i32) : i32
    %33 = llvm.add %25, %32  : i32
    %34 = llvm.mlir.constant(512 : i32) : i32
    %35 = llvm.add %25, %34  : i32
    %36 = llvm.mlir.constant(513 : i32) : i32
    %37 = llvm.add %25, %36  : i32
    %38 = llvm.mlir.constant(514 : i32) : i32
    %39 = llvm.add %25, %38  : i32
    %40 = llvm.mlir.constant(515 : i32) : i32
    %41 = llvm.add %25, %40  : i32
    %42 = builtin.unrealized_conversion_cast %arg2 : !llvm.ptr<1> to !tt.ptr<f32, 1>
    %43 = builtin.unrealized_conversion_cast %arg1 : !llvm.ptr<1> to !tt.ptr<f32, 1>
    %44 = builtin.unrealized_conversion_cast %arg0 : !llvm.ptr<1> to !tt.ptr<f32, 1>
    %45 = llvm.mlir.constant(1024 : i32) : i32
    %46 = genx.workgroup.id.x : i32
    %47 = llvm.mul %46, %45  : i32
    %48 = llvm.mlir.constant(0 : index) : i32
    %49 = llvm.add %27, %48  : i32
    %50 = llvm.add %29, %48  : i32
    %51 = llvm.add %31, %48  : i32
    %52 = llvm.add %33, %48  : i32
    %53 = llvm.add %35, %48  : i32
    %54 = llvm.add %37, %48  : i32
    %55 = llvm.add %39, %48  : i32
    %56 = llvm.add %41, %48  : i32
    %57 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>
    %58 = llvm.insertvalue %49, %57[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %59 = llvm.insertvalue %50, %58[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %60 = llvm.insertvalue %51, %59[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %61 = llvm.insertvalue %52, %60[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %62 = llvm.insertvalue %53, %61[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %63 = llvm.insertvalue %54, %62[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %64 = llvm.insertvalue %55, %63[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %65 = llvm.insertvalue %56, %64[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %66 = llvm.bitcast %47 : i32 to i32
    %67 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>
    %68 = llvm.insertvalue %66, %67[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %69 = llvm.insertvalue %66, %68[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %70 = llvm.insertvalue %66, %69[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %71 = llvm.insertvalue %66, %70[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %72 = llvm.insertvalue %66, %71[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %73 = llvm.insertvalue %66, %72[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %74 = llvm.insertvalue %66, %73[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %75 = llvm.insertvalue %66, %74[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %76 = llvm.extractvalue %75[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %77 = llvm.extractvalue %75[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %78 = llvm.extractvalue %75[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %79 = llvm.extractvalue %75[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %80 = llvm.extractvalue %75[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %81 = llvm.extractvalue %75[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %82 = llvm.extractvalue %75[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %83 = llvm.extractvalue %75[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %84 = llvm.extractvalue %65[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %85 = llvm.extractvalue %65[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %86 = llvm.extractvalue %65[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %87 = llvm.extractvalue %65[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %88 = llvm.extractvalue %65[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %89 = llvm.extractvalue %65[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %90 = llvm.extractvalue %65[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %91 = llvm.extractvalue %65[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %92 = llvm.add %76, %84  : i32
    %93 = llvm.add %77, %85  : i32
    %94 = llvm.add %78, %86  : i32
    %95 = llvm.add %79, %87  : i32
    %96 = llvm.add %80, %88  : i32
    %97 = llvm.add %81, %89  : i32
    %98 = llvm.add %82, %90  : i32
    %99 = llvm.add %83, %91  : i32
    %100 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>
    %101 = llvm.insertvalue %92, %100[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %102 = llvm.insertvalue %93, %101[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %103 = llvm.insertvalue %94, %102[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %104 = llvm.insertvalue %95, %103[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %105 = llvm.insertvalue %96, %104[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %106 = llvm.insertvalue %97, %105[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %107 = llvm.insertvalue %98, %106[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %108 = llvm.insertvalue %99, %107[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %109 = llvm.bitcast %arg3 : i32 to i32
    %110 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>
    %111 = llvm.insertvalue %109, %110[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %112 = llvm.insertvalue %109, %111[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %113 = llvm.insertvalue %109, %112[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %114 = llvm.insertvalue %109, %113[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %115 = llvm.insertvalue %109, %114[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %116 = llvm.insertvalue %109, %115[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %117 = llvm.insertvalue %109, %116[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %118 = llvm.insertvalue %109, %117[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %119 = llvm.extractvalue %108[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %120 = llvm.extractvalue %108[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %121 = llvm.extractvalue %108[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %122 = llvm.extractvalue %108[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %123 = llvm.extractvalue %108[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %124 = llvm.extractvalue %108[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %125 = llvm.extractvalue %108[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %126 = llvm.extractvalue %108[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %127 = llvm.extractvalue %118[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %128 = llvm.extractvalue %118[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %129 = llvm.extractvalue %118[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %130 = llvm.extractvalue %118[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %131 = llvm.extractvalue %118[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %132 = llvm.extractvalue %118[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %133 = llvm.extractvalue %118[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %134 = llvm.extractvalue %118[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %135 = llvm.icmp "slt" %119, %127 : i32
    %136 = llvm.icmp "slt" %120, %128 : i32
    %137 = llvm.icmp "slt" %121, %129 : i32
    %138 = llvm.icmp "slt" %122, %130 : i32
    %139 = llvm.icmp "slt" %123, %131 : i32
    %140 = llvm.icmp "slt" %124, %132 : i32
    %141 = llvm.icmp "slt" %125, %133 : i32
    %142 = llvm.icmp "slt" %126, %134 : i32
    %143 = llvm.mlir.undef : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>
    %144 = llvm.insertvalue %135, %143[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %145 = llvm.insertvalue %135, %144[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %146 = llvm.insertvalue %135, %145[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %147 = llvm.insertvalue %135, %146[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %148 = llvm.insertvalue %139, %147[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %149 = llvm.insertvalue %139, %148[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %150 = llvm.insertvalue %139, %149[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %151 = llvm.insertvalue %139, %150[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %152 = llvm.bitcast %arg0 : !llvm.ptr<1> to !llvm.ptr<1>
    %153 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>
    %154 = llvm.insertvalue %152, %153[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %155 = llvm.insertvalue %152, %154[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %156 = llvm.insertvalue %152, %155[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %157 = llvm.insertvalue %152, %156[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %158 = llvm.insertvalue %152, %157[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %159 = llvm.insertvalue %152, %158[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %160 = llvm.insertvalue %152, %159[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %161 = llvm.insertvalue %152, %160[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %162 = llvm.extractvalue %161[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %163 = llvm.extractvalue %161[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %164 = llvm.extractvalue %161[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %165 = llvm.extractvalue %161[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %166 = llvm.extractvalue %161[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %167 = llvm.extractvalue %161[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %168 = llvm.extractvalue %161[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %169 = llvm.extractvalue %161[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %170 = llvm.extractvalue %108[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %171 = llvm.extractvalue %108[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %172 = llvm.extractvalue %108[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %173 = llvm.extractvalue %108[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %174 = llvm.extractvalue %108[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %175 = llvm.extractvalue %108[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %176 = llvm.extractvalue %108[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %177 = llvm.extractvalue %108[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %178 = llvm.getelementptr %162[%170] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %179 = llvm.getelementptr %163[%171] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %180 = llvm.getelementptr %164[%172] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %181 = llvm.getelementptr %165[%173] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %182 = llvm.getelementptr %166[%174] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %183 = llvm.getelementptr %167[%175] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %184 = llvm.getelementptr %168[%176] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %185 = llvm.getelementptr %169[%177] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %186 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>
    %187 = llvm.insertvalue %178, %186[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %188 = llvm.insertvalue %179, %187[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %189 = llvm.insertvalue %180, %188[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %190 = llvm.insertvalue %181, %189[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %191 = llvm.insertvalue %182, %190[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %192 = llvm.insertvalue %183, %191[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %193 = llvm.insertvalue %184, %192[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %194 = llvm.insertvalue %185, %193[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %195 = llvm.extractvalue %194[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %196 = llvm.extractvalue %194[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %197 = llvm.extractvalue %194[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %198 = llvm.extractvalue %194[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %199 = llvm.extractvalue %194[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %200 = llvm.extractvalue %194[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %201 = llvm.extractvalue %194[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %202 = llvm.extractvalue %194[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %203 = llvm.extractvalue %151[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %204 = llvm.extractvalue %151[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %205 = llvm.extractvalue %151[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %206 = llvm.extractvalue %151[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %207 = llvm.extractvalue %151[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %208 = llvm.extractvalue %151[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %209 = llvm.extractvalue %151[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %210 = llvm.extractvalue %151[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %211 = llvm.mlir.undef : vector<4xi32>
    llvm.cond_br %203, ^bb1, ^bb2(%211 : vector<4xi32>)
  ^bb1:  // pred: ^bb0
    %212 = llvm.bitcast %195 : !llvm.ptr<1> to !llvm.ptr<1>
    %213 = llvm.load %212 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb2(%213 : vector<4xi32>)
  ^bb2(%214: vector<4xi32>):  // 2 preds: ^bb0, ^bb1
    %215 = llvm.mlir.constant(0 : i32) : i32
    %216 = llvm.extractelement %214[%215 : i32] : vector<4xi32>
    %217 = llvm.bitcast %216 : i32 to vector<1xf32>
    %218 = llvm.mlir.constant(1 : i32) : i32
    %219 = llvm.extractelement %214[%218 : i32] : vector<4xi32>
    %220 = llvm.bitcast %219 : i32 to vector<1xf32>
    %221 = llvm.mlir.constant(2 : i32) : i32
    %222 = llvm.extractelement %214[%221 : i32] : vector<4xi32>
    %223 = llvm.bitcast %222 : i32 to vector<1xf32>
    %224 = llvm.mlir.constant(3 : i32) : i32
    %225 = llvm.extractelement %214[%224 : i32] : vector<4xi32>
    %226 = llvm.bitcast %225 : i32 to vector<1xf32>
    %227 = llvm.mlir.constant(0 : i32) : i32
    %228 = llvm.extractelement %217[%227 : i32] : vector<1xf32>
    %229 = llvm.mlir.constant(0 : i32) : i32
    %230 = llvm.extractelement %220[%229 : i32] : vector<1xf32>
    %231 = llvm.mlir.constant(0 : i32) : i32
    %232 = llvm.extractelement %223[%231 : i32] : vector<1xf32>
    %233 = llvm.mlir.constant(0 : i32) : i32
    %234 = llvm.extractelement %226[%233 : i32] : vector<1xf32>
    %235 = llvm.mlir.undef : vector<4xi32>
    llvm.cond_br %207, ^bb3, ^bb4(%235 : vector<4xi32>)
  ^bb3:  // pred: ^bb2
    %236 = llvm.bitcast %199 : !llvm.ptr<1> to !llvm.ptr<1>
    %237 = llvm.load %236 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb4(%237 : vector<4xi32>)
  ^bb4(%238: vector<4xi32>):  // 2 preds: ^bb2, ^bb3
    %239 = llvm.mlir.constant(0 : i32) : i32
    %240 = llvm.extractelement %238[%239 : i32] : vector<4xi32>
    %241 = llvm.bitcast %240 : i32 to vector<1xf32>
    %242 = llvm.mlir.constant(1 : i32) : i32
    %243 = llvm.extractelement %238[%242 : i32] : vector<4xi32>
    %244 = llvm.bitcast %243 : i32 to vector<1xf32>
    %245 = llvm.mlir.constant(2 : i32) : i32
    %246 = llvm.extractelement %238[%245 : i32] : vector<4xi32>
    %247 = llvm.bitcast %246 : i32 to vector<1xf32>
    %248 = llvm.mlir.constant(3 : i32) : i32
    %249 = llvm.extractelement %238[%248 : i32] : vector<4xi32>
    %250 = llvm.bitcast %249 : i32 to vector<1xf32>
    %251 = llvm.mlir.constant(0 : i32) : i32
    %252 = llvm.extractelement %241[%251 : i32] : vector<1xf32>
    %253 = llvm.mlir.constant(0 : i32) : i32
    %254 = llvm.extractelement %244[%253 : i32] : vector<1xf32>
    %255 = llvm.mlir.constant(0 : i32) : i32
    %256 = llvm.extractelement %247[%255 : i32] : vector<1xf32>
    %257 = llvm.mlir.constant(0 : i32) : i32
    %258 = llvm.extractelement %250[%257 : i32] : vector<1xf32>
    %259 = llvm.mlir.undef : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>
    %260 = llvm.insertvalue %228, %259[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %261 = llvm.insertvalue %230, %260[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %262 = llvm.insertvalue %232, %261[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %263 = llvm.insertvalue %234, %262[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %264 = llvm.insertvalue %252, %263[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %265 = llvm.insertvalue %254, %264[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %266 = llvm.insertvalue %256, %265[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %267 = llvm.insertvalue %258, %266[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %268 = llvm.bitcast %arg1 : !llvm.ptr<1> to !llvm.ptr<1>
    %269 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>
    %270 = llvm.insertvalue %268, %269[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %271 = llvm.insertvalue %268, %270[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %272 = llvm.insertvalue %268, %271[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %273 = llvm.insertvalue %268, %272[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %274 = llvm.insertvalue %268, %273[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %275 = llvm.insertvalue %268, %274[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %276 = llvm.insertvalue %268, %275[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %277 = llvm.insertvalue %268, %276[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %278 = llvm.extractvalue %277[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %279 = llvm.extractvalue %277[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %280 = llvm.extractvalue %277[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %281 = llvm.extractvalue %277[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %282 = llvm.extractvalue %277[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %283 = llvm.extractvalue %277[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %284 = llvm.extractvalue %277[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %285 = llvm.extractvalue %277[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %286 = llvm.extractvalue %108[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %287 = llvm.extractvalue %108[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %288 = llvm.extractvalue %108[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %289 = llvm.extractvalue %108[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %290 = llvm.extractvalue %108[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %291 = llvm.extractvalue %108[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %292 = llvm.extractvalue %108[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %293 = llvm.extractvalue %108[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %294 = llvm.getelementptr %278[%286] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %295 = llvm.getelementptr %279[%287] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %296 = llvm.getelementptr %280[%288] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %297 = llvm.getelementptr %281[%289] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %298 = llvm.getelementptr %282[%290] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %299 = llvm.getelementptr %283[%291] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %300 = llvm.getelementptr %284[%292] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %301 = llvm.getelementptr %285[%293] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %302 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>
    %303 = llvm.insertvalue %294, %302[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %304 = llvm.insertvalue %295, %303[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %305 = llvm.insertvalue %296, %304[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %306 = llvm.insertvalue %297, %305[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %307 = llvm.insertvalue %298, %306[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %308 = llvm.insertvalue %299, %307[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %309 = llvm.insertvalue %300, %308[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %310 = llvm.insertvalue %301, %309[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %311 = llvm.extractvalue %310[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %312 = llvm.extractvalue %310[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %313 = llvm.extractvalue %310[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %314 = llvm.extractvalue %310[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %315 = llvm.extractvalue %310[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %316 = llvm.extractvalue %310[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %317 = llvm.extractvalue %310[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %318 = llvm.extractvalue %310[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %319 = llvm.extractvalue %151[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %320 = llvm.extractvalue %151[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %321 = llvm.extractvalue %151[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %322 = llvm.extractvalue %151[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %323 = llvm.extractvalue %151[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %324 = llvm.extractvalue %151[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %325 = llvm.extractvalue %151[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %326 = llvm.extractvalue %151[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %327 = llvm.mlir.undef : vector<4xi32>
    llvm.cond_br %319, ^bb5, ^bb6(%327 : vector<4xi32>)
  ^bb5:  // pred: ^bb4
    %328 = llvm.bitcast %311 : !llvm.ptr<1> to !llvm.ptr<1>
    %329 = llvm.load %328 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb6(%329 : vector<4xi32>)
  ^bb6(%330: vector<4xi32>):  // 2 preds: ^bb4, ^bb5
    %331 = llvm.mlir.constant(0 : i32) : i32
    %332 = llvm.extractelement %330[%331 : i32] : vector<4xi32>
    %333 = llvm.bitcast %332 : i32 to vector<1xf32>
    %334 = llvm.mlir.constant(1 : i32) : i32
    %335 = llvm.extractelement %330[%334 : i32] : vector<4xi32>
    %336 = llvm.bitcast %335 : i32 to vector<1xf32>
    %337 = llvm.mlir.constant(2 : i32) : i32
    %338 = llvm.extractelement %330[%337 : i32] : vector<4xi32>
    %339 = llvm.bitcast %338 : i32 to vector<1xf32>
    %340 = llvm.mlir.constant(3 : i32) : i32
    %341 = llvm.extractelement %330[%340 : i32] : vector<4xi32>
    %342 = llvm.bitcast %341 : i32 to vector<1xf32>
    %343 = llvm.mlir.constant(0 : i32) : i32
    %344 = llvm.extractelement %333[%343 : i32] : vector<1xf32>
    %345 = llvm.mlir.constant(0 : i32) : i32
    %346 = llvm.extractelement %336[%345 : i32] : vector<1xf32>
    %347 = llvm.mlir.constant(0 : i32) : i32
    %348 = llvm.extractelement %339[%347 : i32] : vector<1xf32>
    %349 = llvm.mlir.constant(0 : i32) : i32
    %350 = llvm.extractelement %342[%349 : i32] : vector<1xf32>
    %351 = llvm.mlir.undef : vector<4xi32>
    llvm.cond_br %323, ^bb7, ^bb8(%351 : vector<4xi32>)
  ^bb7:  // pred: ^bb6
    %352 = llvm.bitcast %315 : !llvm.ptr<1> to !llvm.ptr<1>
    %353 = llvm.load %352 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb8(%353 : vector<4xi32>)
  ^bb8(%354: vector<4xi32>):  // 2 preds: ^bb6, ^bb7
    %355 = llvm.mlir.constant(0 : i32) : i32
    %356 = llvm.extractelement %354[%355 : i32] : vector<4xi32>
    %357 = llvm.bitcast %356 : i32 to vector<1xf32>
    %358 = llvm.mlir.constant(1 : i32) : i32
    %359 = llvm.extractelement %354[%358 : i32] : vector<4xi32>
    %360 = llvm.bitcast %359 : i32 to vector<1xf32>
    %361 = llvm.mlir.constant(2 : i32) : i32
    %362 = llvm.extractelement %354[%361 : i32] : vector<4xi32>
    %363 = llvm.bitcast %362 : i32 to vector<1xf32>
    %364 = llvm.mlir.constant(3 : i32) : i32
    %365 = llvm.extractelement %354[%364 : i32] : vector<4xi32>
    %366 = llvm.bitcast %365 : i32 to vector<1xf32>
    %367 = llvm.mlir.constant(0 : i32) : i32
    %368 = llvm.extractelement %357[%367 : i32] : vector<1xf32>
    %369 = llvm.mlir.constant(0 : i32) : i32
    %370 = llvm.extractelement %360[%369 : i32] : vector<1xf32>
    %371 = llvm.mlir.constant(0 : i32) : i32
    %372 = llvm.extractelement %363[%371 : i32] : vector<1xf32>
    %373 = llvm.mlir.constant(0 : i32) : i32
    %374 = llvm.extractelement %366[%373 : i32] : vector<1xf32>
    %375 = llvm.mlir.undef : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>
    %376 = llvm.insertvalue %344, %375[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %377 = llvm.insertvalue %346, %376[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %378 = llvm.insertvalue %348, %377[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %379 = llvm.insertvalue %350, %378[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %380 = llvm.insertvalue %368, %379[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %381 = llvm.insertvalue %370, %380[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %382 = llvm.insertvalue %372, %381[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %383 = llvm.insertvalue %374, %382[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %384 = llvm.extractvalue %267[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %385 = llvm.extractvalue %267[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %386 = llvm.extractvalue %267[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %387 = llvm.extractvalue %267[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %388 = llvm.extractvalue %267[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %389 = llvm.extractvalue %267[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %390 = llvm.extractvalue %267[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %391 = llvm.extractvalue %267[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %392 = llvm.extractvalue %383[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %393 = llvm.extractvalue %383[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %394 = llvm.extractvalue %383[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %395 = llvm.extractvalue %383[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %396 = llvm.extractvalue %383[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %397 = llvm.extractvalue %383[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %398 = llvm.extractvalue %383[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %399 = llvm.extractvalue %383[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %400 = llvm.fadd %384, %392  : f32
    %401 = llvm.fadd %385, %393  : f32
    %402 = llvm.fadd %386, %394  : f32
    %403 = llvm.fadd %387, %395  : f32
    %404 = llvm.fadd %388, %396  : f32
    %405 = llvm.fadd %389, %397  : f32
    %406 = llvm.fadd %390, %398  : f32
    %407 = llvm.fadd %391, %399  : f32
    %408 = llvm.mlir.undef : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>
    %409 = llvm.insertvalue %400, %408[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %410 = llvm.insertvalue %401, %409[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %411 = llvm.insertvalue %402, %410[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %412 = llvm.insertvalue %403, %411[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %413 = llvm.insertvalue %404, %412[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %414 = llvm.insertvalue %405, %413[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %415 = llvm.insertvalue %406, %414[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %416 = llvm.insertvalue %407, %415[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %417 = llvm.bitcast %arg2 : !llvm.ptr<1> to !llvm.ptr<1>
    %418 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>
    %419 = llvm.insertvalue %417, %418[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %420 = llvm.insertvalue %417, %419[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %421 = llvm.insertvalue %417, %420[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %422 = llvm.insertvalue %417, %421[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %423 = llvm.insertvalue %417, %422[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %424 = llvm.insertvalue %417, %423[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %425 = llvm.insertvalue %417, %424[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %426 = llvm.insertvalue %417, %425[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %427 = llvm.extractvalue %426[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %428 = llvm.extractvalue %426[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %429 = llvm.extractvalue %426[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %430 = llvm.extractvalue %426[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %431 = llvm.extractvalue %426[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %432 = llvm.extractvalue %426[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %433 = llvm.extractvalue %426[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %434 = llvm.extractvalue %426[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %435 = llvm.extractvalue %108[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %436 = llvm.extractvalue %108[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %437 = llvm.extractvalue %108[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %438 = llvm.extractvalue %108[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %439 = llvm.extractvalue %108[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %440 = llvm.extractvalue %108[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %441 = llvm.extractvalue %108[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %442 = llvm.extractvalue %108[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> 
    %443 = llvm.getelementptr %427[%435] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %444 = llvm.getelementptr %428[%436] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %445 = llvm.getelementptr %429[%437] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %446 = llvm.getelementptr %430[%438] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %447 = llvm.getelementptr %431[%439] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %448 = llvm.getelementptr %432[%440] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %449 = llvm.getelementptr %433[%441] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %450 = llvm.getelementptr %434[%442] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %451 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>
    %452 = llvm.insertvalue %443, %451[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %453 = llvm.insertvalue %444, %452[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %454 = llvm.insertvalue %445, %453[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %455 = llvm.insertvalue %446, %454[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %456 = llvm.insertvalue %447, %455[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %457 = llvm.insertvalue %448, %456[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %458 = llvm.insertvalue %449, %457[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %459 = llvm.insertvalue %450, %458[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %460 = llvm.extractvalue %459[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %461 = llvm.extractvalue %459[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %462 = llvm.extractvalue %459[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %463 = llvm.extractvalue %459[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %464 = llvm.extractvalue %459[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %465 = llvm.extractvalue %459[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %466 = llvm.extractvalue %459[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %467 = llvm.extractvalue %459[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> 
    %468 = llvm.extractvalue %416[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %469 = llvm.extractvalue %416[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %470 = llvm.extractvalue %416[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %471 = llvm.extractvalue %416[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %472 = llvm.extractvalue %416[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %473 = llvm.extractvalue %416[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %474 = llvm.extractvalue %416[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %475 = llvm.extractvalue %416[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> 
    %476 = llvm.extractvalue %151[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %477 = llvm.extractvalue %151[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %478 = llvm.extractvalue %151[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %479 = llvm.extractvalue %151[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %480 = llvm.extractvalue %151[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %481 = llvm.extractvalue %151[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %482 = llvm.extractvalue %151[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %483 = llvm.extractvalue %151[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> 
    %484 = llvm.mlir.constant(true) : i1
    %485 = genx.workitem.id.x : i32
    %486 = llvm.mlir.constant(0 : i32) : i32
    %487 = llvm.mlir.constant(32 : i32) : i32
    %488 = llvm.urem %485, %487  : i32
    %489 = llvm.udiv %485, %487  : i32
    %490 = llvm.mlir.constant(4 : i32) : i32
    %491 = llvm.urem %489, %490  : i32
    %492 = llvm.udiv %489, %490  : i32
    %493 = llvm.mlir.constant(32 : i32) : i32
    %494 = llvm.urem %488, %493  : i32
    %495 = llvm.udiv %488, %493  : i32
    %496 = llvm.mlir.undef : vector<1xf32>
    %497 = llvm.bitcast %468 : f32 to f32
    %498 = llvm.mlir.constant(0 : i32) : i32
    %499 = llvm.insertelement %497, %496[%498 : i32] : vector<1xf32>
    %500 = llvm.bitcast %499 : vector<1xf32> to i32
    %501 = llvm.mlir.undef : vector<1xf32>
    %502 = llvm.bitcast %469 : f32 to f32
    %503 = llvm.mlir.constant(0 : i32) : i32
    %504 = llvm.insertelement %502, %501[%503 : i32] : vector<1xf32>
    %505 = llvm.bitcast %504 : vector<1xf32> to i32
    %506 = llvm.mlir.undef : vector<1xf32>
    %507 = llvm.bitcast %470 : f32 to f32
    %508 = llvm.mlir.constant(0 : i32) : i32
    %509 = llvm.insertelement %507, %506[%508 : i32] : vector<1xf32>
    %510 = llvm.bitcast %509 : vector<1xf32> to i32
    %511 = llvm.mlir.undef : vector<1xf32>
    %512 = llvm.bitcast %471 : f32 to f32
    %513 = llvm.mlir.constant(0 : i32) : i32
    %514 = llvm.insertelement %512, %511[%513 : i32] : vector<1xf32>
    %515 = llvm.bitcast %514 : vector<1xf32> to i32
    %516 = llvm.and %484, %476  : i1
    %517 = llvm.mlir.undef : vector<4xi32>
    %518 = llvm.mlir.constant(0 : i32) : i32
    %519 = llvm.insertelement %500, %517[%518 : i32] : vector<4xi32>
    %520 = llvm.mlir.constant(1 : i32) : i32
    %521 = llvm.insertelement %505, %519[%520 : i32] : vector<4xi32>
    %522 = llvm.mlir.constant(2 : i32) : i32
    %523 = llvm.insertelement %510, %521[%522 : i32] : vector<4xi32>
    %524 = llvm.mlir.constant(3 : i32) : i32
    %525 = llvm.insertelement %515, %523[%524 : i32] : vector<4xi32>
    llvm.cond_br %516, ^bb9, ^bb10
  ^bb9:  // pred: ^bb8
    %526 = llvm.bitcast %460 : !llvm.ptr<1> to !llvm.ptr<1>
    llvm.store %525, %526 : vector<4xi32>, !llvm.ptr<1>
    llvm.br ^bb10
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %527 = llvm.mlir.undef : vector<1xf32>
    %528 = llvm.bitcast %472 : f32 to f32
    %529 = llvm.mlir.constant(0 : i32) : i32
    %530 = llvm.insertelement %528, %527[%529 : i32] : vector<1xf32>
    %531 = llvm.bitcast %530 : vector<1xf32> to i32
    %532 = llvm.mlir.undef : vector<1xf32>
    %533 = llvm.bitcast %473 : f32 to f32
    %534 = llvm.mlir.constant(0 : i32) : i32
    %535 = llvm.insertelement %533, %532[%534 : i32] : vector<1xf32>
    %536 = llvm.bitcast %535 : vector<1xf32> to i32
    %537 = llvm.mlir.undef : vector<1xf32>
    %538 = llvm.bitcast %474 : f32 to f32
    %539 = llvm.mlir.constant(0 : i32) : i32
    %540 = llvm.insertelement %538, %537[%539 : i32] : vector<1xf32>
    %541 = llvm.bitcast %540 : vector<1xf32> to i32
    %542 = llvm.mlir.undef : vector<1xf32>
    %543 = llvm.bitcast %475 : f32 to f32
    %544 = llvm.mlir.constant(0 : i32) : i32
    %545 = llvm.insertelement %543, %542[%544 : i32] : vector<1xf32>
    %546 = llvm.bitcast %545 : vector<1xf32> to i32
    %547 = llvm.and %484, %480  : i1
    %548 = llvm.mlir.undef : vector<4xi32>
    %549 = llvm.mlir.constant(0 : i32) : i32
    %550 = llvm.insertelement %531, %548[%549 : i32] : vector<4xi32>
    %551 = llvm.mlir.constant(1 : i32) : i32
    %552 = llvm.insertelement %536, %550[%551 : i32] : vector<4xi32>
    %553 = llvm.mlir.constant(2 : i32) : i32
    %554 = llvm.insertelement %541, %552[%553 : i32] : vector<4xi32>
    %555 = llvm.mlir.constant(3 : i32) : i32
    %556 = llvm.insertelement %546, %554[%555 : i32] : vector<4xi32>
    llvm.cond_br %547, ^bb11, ^bb12
  ^bb11:  // pred: ^bb10
    %557 = llvm.bitcast %464 : !llvm.ptr<1> to !llvm.ptr<1>
    llvm.store %556, %557 : vector<4xi32>, !llvm.ptr<1>
    llvm.br ^bb12
  ^bb12:  // 2 preds: ^bb10, ^bb11
    llvm.return
  }
}


// -----// IR Dump After Canonicalizer (canonicalize) //----- //
module attributes {"triton_gpu.compute-capability" = 80 : i32, "triton_gpu.num-ctas" = 1 : i32, "triton_gpu.num-warps" = 4 : i32, triton_gpu.shared = 0 : i32, "triton_gpu.threads-per-warp" = 32 : i32} {
  llvm.func @add_kernel_0d1d2d3de(%arg0: !llvm.ptr<1> {tt.divisibility = 16 : i32}, %arg1: !llvm.ptr<1> {tt.divisibility = 16 : i32}, %arg2: !llvm.ptr<1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {genx.intel_reqd_sub_group_size = [32 : i32], genx.kernel = 1 : i32, genx.max_work_group_size = [128 : i32, 1 : i32, 1 : i32], noinline = false, sym_visibility = "public", "triton_gpu.num-tma-load" = 0 : i32, "triton_gpu.num-tma-store" = 0 : i32} {
    %0 = llvm.mlir.constant(true) : i1
    %1 = llvm.mlir.constant(0 : index) : i32
    %2 = llvm.mlir.constant(512 : i32) : i32
    %3 = llvm.mlir.constant(3 : i32) : i32
    %4 = llvm.mlir.constant(2 : i32) : i32
    %5 = llvm.mlir.constant(1024 : i32) : i32
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.mlir.constant(0 : i32) : i32
    %8 = llvm.mlir.constant(256 : i32) : i32
    %9 = llvm.mlir.constant(8 : i32) : i32
    %10 = llvm.mlir.constant(4 : i32) : i32
    %11 = llvm.mlir.constant(32 : i32) : i32
    %12 = genx.workitem.id.x : i32
    %13 = llvm.urem %12, %11  : i32
    %14 = llvm.udiv %12, %11  : i32
    %15 = llvm.urem %14, %10  : i32
    %16 = llvm.urem %13, %11  : i32
    %17 = llvm.urem %15, %9  : i32
    %18 = llvm.urem %16, %8  : i32
    %19 = llvm.mul %17, %11  : i32
    %20 = llvm.add %18, %19  : i32
    %21 = llvm.mul %20, %10  : i32
    %22 = llvm.urem %7, %6  : i32
    %23 = llvm.mul %22, %5  : i32
    %24 = llvm.add %21, %23  : i32
    %25 = llvm.add %24, %7  : i32
    %26 = llvm.add %24, %2  : i32
    %27 = genx.workgroup.id.x : i32
    %28 = llvm.mul %27, %5  : i32
    %29 = llvm.add %25, %1  : i32
    %30 = llvm.add %26, %1  : i32
    %31 = llvm.add %28, %29  : i32
    %32 = llvm.add %28, %30  : i32
    %33 = llvm.icmp "slt" %31, %arg3 : i32
    %34 = llvm.icmp "slt" %32, %arg3 : i32
    %35 = llvm.getelementptr %arg0[%31] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %36 = llvm.getelementptr %arg0[%32] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %37 = llvm.mlir.undef : vector<4xi32>
    llvm.cond_br %33, ^bb1, ^bb2(%37 : vector<4xi32>)
  ^bb1:  // pred: ^bb0
    %38 = llvm.load %35 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb2(%38 : vector<4xi32>)
  ^bb2(%39: vector<4xi32>):  // 2 preds: ^bb0, ^bb1
    %40 = llvm.extractelement %39[%7 : i32] : vector<4xi32>
    %41 = llvm.bitcast %40 : i32 to vector<1xf32>
    %42 = llvm.extractelement %39[%6 : i32] : vector<4xi32>
    %43 = llvm.bitcast %42 : i32 to vector<1xf32>
    %44 = llvm.extractelement %39[%4 : i32] : vector<4xi32>
    %45 = llvm.bitcast %44 : i32 to vector<1xf32>
    %46 = llvm.extractelement %39[%3 : i32] : vector<4xi32>
    %47 = llvm.bitcast %46 : i32 to vector<1xf32>
    %48 = llvm.extractelement %41[%7 : i32] : vector<1xf32>
    %49 = llvm.extractelement %43[%7 : i32] : vector<1xf32>
    %50 = llvm.extractelement %45[%7 : i32] : vector<1xf32>
    %51 = llvm.extractelement %47[%7 : i32] : vector<1xf32>
    %52 = llvm.mlir.undef : vector<4xi32>
    llvm.cond_br %34, ^bb3, ^bb4(%52 : vector<4xi32>)
  ^bb3:  // pred: ^bb2
    %53 = llvm.load %36 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb4(%53 : vector<4xi32>)
  ^bb4(%54: vector<4xi32>):  // 2 preds: ^bb2, ^bb3
    %55 = llvm.extractelement %54[%7 : i32] : vector<4xi32>
    %56 = llvm.bitcast %55 : i32 to vector<1xf32>
    %57 = llvm.extractelement %54[%6 : i32] : vector<4xi32>
    %58 = llvm.bitcast %57 : i32 to vector<1xf32>
    %59 = llvm.extractelement %54[%4 : i32] : vector<4xi32>
    %60 = llvm.bitcast %59 : i32 to vector<1xf32>
    %61 = llvm.extractelement %54[%3 : i32] : vector<4xi32>
    %62 = llvm.bitcast %61 : i32 to vector<1xf32>
    %63 = llvm.extractelement %56[%7 : i32] : vector<1xf32>
    %64 = llvm.extractelement %58[%7 : i32] : vector<1xf32>
    %65 = llvm.extractelement %60[%7 : i32] : vector<1xf32>
    %66 = llvm.extractelement %62[%7 : i32] : vector<1xf32>
    %67 = llvm.getelementptr %arg1[%31] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %68 = llvm.getelementptr %arg1[%32] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %69 = llvm.mlir.undef : vector<4xi32>
    llvm.cond_br %33, ^bb5, ^bb6(%69 : vector<4xi32>)
  ^bb5:  // pred: ^bb4
    %70 = llvm.load %67 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb6(%70 : vector<4xi32>)
  ^bb6(%71: vector<4xi32>):  // 2 preds: ^bb4, ^bb5
    %72 = llvm.extractelement %71[%7 : i32] : vector<4xi32>
    %73 = llvm.bitcast %72 : i32 to vector<1xf32>
    %74 = llvm.extractelement %71[%6 : i32] : vector<4xi32>
    %75 = llvm.bitcast %74 : i32 to vector<1xf32>
    %76 = llvm.extractelement %71[%4 : i32] : vector<4xi32>
    %77 = llvm.bitcast %76 : i32 to vector<1xf32>
    %78 = llvm.extractelement %71[%3 : i32] : vector<4xi32>
    %79 = llvm.bitcast %78 : i32 to vector<1xf32>
    %80 = llvm.extractelement %73[%7 : i32] : vector<1xf32>
    %81 = llvm.extractelement %75[%7 : i32] : vector<1xf32>
    %82 = llvm.extractelement %77[%7 : i32] : vector<1xf32>
    %83 = llvm.extractelement %79[%7 : i32] : vector<1xf32>
    %84 = llvm.mlir.undef : vector<4xi32>
    llvm.cond_br %34, ^bb7, ^bb8(%84 : vector<4xi32>)
  ^bb7:  // pred: ^bb6
    %85 = llvm.load %68 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb8(%85 : vector<4xi32>)
  ^bb8(%86: vector<4xi32>):  // 2 preds: ^bb6, ^bb7
    %87 = llvm.extractelement %86[%7 : i32] : vector<4xi32>
    %88 = llvm.bitcast %87 : i32 to vector<1xf32>
    %89 = llvm.extractelement %86[%6 : i32] : vector<4xi32>
    %90 = llvm.bitcast %89 : i32 to vector<1xf32>
    %91 = llvm.extractelement %86[%4 : i32] : vector<4xi32>
    %92 = llvm.bitcast %91 : i32 to vector<1xf32>
    %93 = llvm.extractelement %86[%3 : i32] : vector<4xi32>
    %94 = llvm.bitcast %93 : i32 to vector<1xf32>
    %95 = llvm.extractelement %88[%7 : i32] : vector<1xf32>
    %96 = llvm.extractelement %90[%7 : i32] : vector<1xf32>
    %97 = llvm.extractelement %92[%7 : i32] : vector<1xf32>
    %98 = llvm.extractelement %94[%7 : i32] : vector<1xf32>
    %99 = llvm.fadd %48, %80  : f32
    %100 = llvm.fadd %49, %81  : f32
    %101 = llvm.fadd %50, %82  : f32
    %102 = llvm.fadd %51, %83  : f32
    %103 = llvm.fadd %63, %95  : f32
    %104 = llvm.fadd %64, %96  : f32
    %105 = llvm.fadd %65, %97  : f32
    %106 = llvm.fadd %66, %98  : f32
    %107 = llvm.getelementptr %arg2[%31] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %108 = llvm.getelementptr %arg2[%32] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %109 = llvm.mlir.undef : vector<1xf32>
    %110 = llvm.insertelement %99, %109[%7 : i32] : vector<1xf32>
    %111 = llvm.bitcast %110 : vector<1xf32> to i32
    %112 = llvm.mlir.undef : vector<1xf32>
    %113 = llvm.insertelement %100, %112[%7 : i32] : vector<1xf32>
    %114 = llvm.bitcast %113 : vector<1xf32> to i32
    %115 = llvm.mlir.undef : vector<1xf32>
    %116 = llvm.insertelement %101, %115[%7 : i32] : vector<1xf32>
    %117 = llvm.bitcast %116 : vector<1xf32> to i32
    %118 = llvm.mlir.undef : vector<1xf32>
    %119 = llvm.insertelement %102, %118[%7 : i32] : vector<1xf32>
    %120 = llvm.bitcast %119 : vector<1xf32> to i32
    %121 = llvm.and %0, %33  : i1
    %122 = llvm.mlir.undef : vector<4xi32>
    %123 = llvm.insertelement %111, %122[%7 : i32] : vector<4xi32>
    %124 = llvm.insertelement %114, %123[%6 : i32] : vector<4xi32>
    %125 = llvm.insertelement %117, %124[%4 : i32] : vector<4xi32>
    %126 = llvm.insertelement %120, %125[%3 : i32] : vector<4xi32>
    llvm.cond_br %121, ^bb9, ^bb10
  ^bb9:  // pred: ^bb8
    llvm.store %126, %107 : vector<4xi32>, !llvm.ptr<1>
    llvm.br ^bb10
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %127 = llvm.mlir.undef : vector<1xf32>
    %128 = llvm.insertelement %103, %127[%7 : i32] : vector<1xf32>
    %129 = llvm.bitcast %128 : vector<1xf32> to i32
    %130 = llvm.mlir.undef : vector<1xf32>
    %131 = llvm.insertelement %104, %130[%7 : i32] : vector<1xf32>
    %132 = llvm.bitcast %131 : vector<1xf32> to i32
    %133 = llvm.mlir.undef : vector<1xf32>
    %134 = llvm.insertelement %105, %133[%7 : i32] : vector<1xf32>
    %135 = llvm.bitcast %134 : vector<1xf32> to i32
    %136 = llvm.mlir.undef : vector<1xf32>
    %137 = llvm.insertelement %106, %136[%7 : i32] : vector<1xf32>
    %138 = llvm.bitcast %137 : vector<1xf32> to i32
    %139 = llvm.and %0, %34  : i1
    %140 = llvm.mlir.undef : vector<4xi32>
    %141 = llvm.insertelement %129, %140[%7 : i32] : vector<4xi32>
    %142 = llvm.insertelement %132, %141[%6 : i32] : vector<4xi32>
    %143 = llvm.insertelement %135, %142[%4 : i32] : vector<4xi32>
    %144 = llvm.insertelement %138, %143[%3 : i32] : vector<4xi32>
    llvm.cond_br %139, ^bb11, ^bb12
  ^bb11:  // pred: ^bb10
    llvm.store %144, %108 : vector<4xi32>, !llvm.ptr<1>
    llvm.br ^bb12
  ^bb12:  // 2 preds: ^bb10, ^bb11
    llvm.return
  }
}


// -----// IR Dump After CSE (cse) //----- //
module attributes {"triton_gpu.compute-capability" = 80 : i32, "triton_gpu.num-ctas" = 1 : i32, "triton_gpu.num-warps" = 4 : i32, triton_gpu.shared = 0 : i32, "triton_gpu.threads-per-warp" = 32 : i32} {
  llvm.func @add_kernel_0d1d2d3de(%arg0: !llvm.ptr<1> {tt.divisibility = 16 : i32}, %arg1: !llvm.ptr<1> {tt.divisibility = 16 : i32}, %arg2: !llvm.ptr<1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {genx.intel_reqd_sub_group_size = [32 : i32], genx.kernel = 1 : i32, genx.max_work_group_size = [128 : i32, 1 : i32, 1 : i32], noinline = false, sym_visibility = "public", "triton_gpu.num-tma-load" = 0 : i32, "triton_gpu.num-tma-store" = 0 : i32} {
    %0 = llvm.mlir.constant(true) : i1
    %1 = llvm.mlir.constant(0 : index) : i32
    %2 = llvm.mlir.constant(512 : i32) : i32
    %3 = llvm.mlir.constant(3 : i32) : i32
    %4 = llvm.mlir.constant(2 : i32) : i32
    %5 = llvm.mlir.constant(1024 : i32) : i32
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.mlir.constant(0 : i32) : i32
    %8 = llvm.mlir.constant(256 : i32) : i32
    %9 = llvm.mlir.constant(8 : i32) : i32
    %10 = llvm.mlir.constant(4 : i32) : i32
    %11 = llvm.mlir.constant(32 : i32) : i32
    %12 = genx.workitem.id.x : i32
    %13 = llvm.urem %12, %11  : i32
    %14 = llvm.udiv %12, %11  : i32
    %15 = llvm.urem %14, %10  : i32
    %16 = llvm.urem %13, %11  : i32
    %17 = llvm.urem %15, %9  : i32
    %18 = llvm.urem %16, %8  : i32
    %19 = llvm.mul %17, %11  : i32
    %20 = llvm.add %18, %19  : i32
    %21 = llvm.mul %20, %10  : i32
    %22 = llvm.urem %7, %6  : i32
    %23 = llvm.mul %22, %5  : i32
    %24 = llvm.add %21, %23  : i32
    %25 = llvm.add %24, %7  : i32
    %26 = llvm.add %24, %2  : i32
    %27 = genx.workgroup.id.x : i32
    %28 = llvm.mul %27, %5  : i32
    %29 = llvm.add %25, %1  : i32
    %30 = llvm.add %26, %1  : i32
    %31 = llvm.add %28, %29  : i32
    %32 = llvm.add %28, %30  : i32
    %33 = llvm.icmp "slt" %31, %arg3 : i32
    %34 = llvm.icmp "slt" %32, %arg3 : i32
    %35 = llvm.getelementptr %arg0[%31] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %36 = llvm.getelementptr %arg0[%32] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %37 = llvm.mlir.undef : vector<4xi32>
    llvm.cond_br %33, ^bb1, ^bb2(%37 : vector<4xi32>)
  ^bb1:  // pred: ^bb0
    %38 = llvm.load %35 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb2(%38 : vector<4xi32>)
  ^bb2(%39: vector<4xi32>):  // 2 preds: ^bb0, ^bb1
    %40 = llvm.extractelement %39[%7 : i32] : vector<4xi32>
    %41 = llvm.bitcast %40 : i32 to vector<1xf32>
    %42 = llvm.extractelement %39[%6 : i32] : vector<4xi32>
    %43 = llvm.bitcast %42 : i32 to vector<1xf32>
    %44 = llvm.extractelement %39[%4 : i32] : vector<4xi32>
    %45 = llvm.bitcast %44 : i32 to vector<1xf32>
    %46 = llvm.extractelement %39[%3 : i32] : vector<4xi32>
    %47 = llvm.bitcast %46 : i32 to vector<1xf32>
    %48 = llvm.extractelement %41[%7 : i32] : vector<1xf32>
    %49 = llvm.extractelement %43[%7 : i32] : vector<1xf32>
    %50 = llvm.extractelement %45[%7 : i32] : vector<1xf32>
    %51 = llvm.extractelement %47[%7 : i32] : vector<1xf32>
    llvm.cond_br %34, ^bb3, ^bb4(%37 : vector<4xi32>)
  ^bb3:  // pred: ^bb2
    %52 = llvm.load %36 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb4(%52 : vector<4xi32>)
  ^bb4(%53: vector<4xi32>):  // 2 preds: ^bb2, ^bb3
    %54 = llvm.extractelement %53[%7 : i32] : vector<4xi32>
    %55 = llvm.bitcast %54 : i32 to vector<1xf32>
    %56 = llvm.extractelement %53[%6 : i32] : vector<4xi32>
    %57 = llvm.bitcast %56 : i32 to vector<1xf32>
    %58 = llvm.extractelement %53[%4 : i32] : vector<4xi32>
    %59 = llvm.bitcast %58 : i32 to vector<1xf32>
    %60 = llvm.extractelement %53[%3 : i32] : vector<4xi32>
    %61 = llvm.bitcast %60 : i32 to vector<1xf32>
    %62 = llvm.extractelement %55[%7 : i32] : vector<1xf32>
    %63 = llvm.extractelement %57[%7 : i32] : vector<1xf32>
    %64 = llvm.extractelement %59[%7 : i32] : vector<1xf32>
    %65 = llvm.extractelement %61[%7 : i32] : vector<1xf32>
    %66 = llvm.getelementptr %arg1[%31] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %67 = llvm.getelementptr %arg1[%32] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    llvm.cond_br %33, ^bb5, ^bb6(%37 : vector<4xi32>)
  ^bb5:  // pred: ^bb4
    %68 = llvm.load %66 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb6(%68 : vector<4xi32>)
  ^bb6(%69: vector<4xi32>):  // 2 preds: ^bb4, ^bb5
    %70 = llvm.extractelement %69[%7 : i32] : vector<4xi32>
    %71 = llvm.bitcast %70 : i32 to vector<1xf32>
    %72 = llvm.extractelement %69[%6 : i32] : vector<4xi32>
    %73 = llvm.bitcast %72 : i32 to vector<1xf32>
    %74 = llvm.extractelement %69[%4 : i32] : vector<4xi32>
    %75 = llvm.bitcast %74 : i32 to vector<1xf32>
    %76 = llvm.extractelement %69[%3 : i32] : vector<4xi32>
    %77 = llvm.bitcast %76 : i32 to vector<1xf32>
    %78 = llvm.extractelement %71[%7 : i32] : vector<1xf32>
    %79 = llvm.extractelement %73[%7 : i32] : vector<1xf32>
    %80 = llvm.extractelement %75[%7 : i32] : vector<1xf32>
    %81 = llvm.extractelement %77[%7 : i32] : vector<1xf32>
    llvm.cond_br %34, ^bb7, ^bb8(%37 : vector<4xi32>)
  ^bb7:  // pred: ^bb6
    %82 = llvm.load %67 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb8(%82 : vector<4xi32>)
  ^bb8(%83: vector<4xi32>):  // 2 preds: ^bb6, ^bb7
    %84 = llvm.extractelement %83[%7 : i32] : vector<4xi32>
    %85 = llvm.bitcast %84 : i32 to vector<1xf32>
    %86 = llvm.extractelement %83[%6 : i32] : vector<4xi32>
    %87 = llvm.bitcast %86 : i32 to vector<1xf32>
    %88 = llvm.extractelement %83[%4 : i32] : vector<4xi32>
    %89 = llvm.bitcast %88 : i32 to vector<1xf32>
    %90 = llvm.extractelement %83[%3 : i32] : vector<4xi32>
    %91 = llvm.bitcast %90 : i32 to vector<1xf32>
    %92 = llvm.extractelement %85[%7 : i32] : vector<1xf32>
    %93 = llvm.extractelement %87[%7 : i32] : vector<1xf32>
    %94 = llvm.extractelement %89[%7 : i32] : vector<1xf32>
    %95 = llvm.extractelement %91[%7 : i32] : vector<1xf32>
    %96 = llvm.fadd %48, %78  : f32
    %97 = llvm.fadd %49, %79  : f32
    %98 = llvm.fadd %50, %80  : f32
    %99 = llvm.fadd %51, %81  : f32
    %100 = llvm.fadd %62, %92  : f32
    %101 = llvm.fadd %63, %93  : f32
    %102 = llvm.fadd %64, %94  : f32
    %103 = llvm.fadd %65, %95  : f32
    %104 = llvm.getelementptr %arg2[%31] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %105 = llvm.getelementptr %arg2[%32] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %106 = llvm.mlir.undef : vector<1xf32>
    %107 = llvm.insertelement %96, %106[%7 : i32] : vector<1xf32>
    %108 = llvm.bitcast %107 : vector<1xf32> to i32
    %109 = llvm.insertelement %97, %106[%7 : i32] : vector<1xf32>
    %110 = llvm.bitcast %109 : vector<1xf32> to i32
    %111 = llvm.insertelement %98, %106[%7 : i32] : vector<1xf32>
    %112 = llvm.bitcast %111 : vector<1xf32> to i32
    %113 = llvm.insertelement %99, %106[%7 : i32] : vector<1xf32>
    %114 = llvm.bitcast %113 : vector<1xf32> to i32
    %115 = llvm.and %0, %33  : i1
    %116 = llvm.insertelement %108, %37[%7 : i32] : vector<4xi32>
    %117 = llvm.insertelement %110, %116[%6 : i32] : vector<4xi32>
    %118 = llvm.insertelement %112, %117[%4 : i32] : vector<4xi32>
    %119 = llvm.insertelement %114, %118[%3 : i32] : vector<4xi32>
    llvm.cond_br %115, ^bb9, ^bb10
  ^bb9:  // pred: ^bb8
    llvm.store %119, %104 : vector<4xi32>, !llvm.ptr<1>
    llvm.br ^bb10
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %120 = llvm.insertelement %100, %106[%7 : i32] : vector<1xf32>
    %121 = llvm.bitcast %120 : vector<1xf32> to i32
    %122 = llvm.insertelement %101, %106[%7 : i32] : vector<1xf32>
    %123 = llvm.bitcast %122 : vector<1xf32> to i32
    %124 = llvm.insertelement %102, %106[%7 : i32] : vector<1xf32>
    %125 = llvm.bitcast %124 : vector<1xf32> to i32
    %126 = llvm.insertelement %103, %106[%7 : i32] : vector<1xf32>
    %127 = llvm.bitcast %126 : vector<1xf32> to i32
    %128 = llvm.and %0, %34  : i1
    %129 = llvm.insertelement %121, %37[%7 : i32] : vector<4xi32>
    %130 = llvm.insertelement %123, %129[%6 : i32] : vector<4xi32>
    %131 = llvm.insertelement %125, %130[%4 : i32] : vector<4xi32>
    %132 = llvm.insertelement %127, %131[%3 : i32] : vector<4xi32>
    llvm.cond_br %128, ^bb11, ^bb12
  ^bb11:  // pred: ^bb10
    llvm.store %132, %105 : vector<4xi32>, !llvm.ptr<1>
    llvm.br ^bb12
  ^bb12:  // 2 preds: ^bb10, ^bb11
    llvm.return
  }
}


// -----// IR Dump After SymbolDCE (symbol-dce) //----- //
module attributes {"triton_gpu.compute-capability" = 80 : i32, "triton_gpu.num-ctas" = 1 : i32, "triton_gpu.num-warps" = 4 : i32, triton_gpu.shared = 0 : i32, "triton_gpu.threads-per-warp" = 32 : i32} {
  llvm.func @add_kernel_0d1d2d3de(%arg0: !llvm.ptr<1> {tt.divisibility = 16 : i32}, %arg1: !llvm.ptr<1> {tt.divisibility = 16 : i32}, %arg2: !llvm.ptr<1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {genx.intel_reqd_sub_group_size = [32 : i32], genx.kernel = 1 : i32, genx.max_work_group_size = [128 : i32, 1 : i32, 1 : i32], noinline = false, sym_visibility = "public", "triton_gpu.num-tma-load" = 0 : i32, "triton_gpu.num-tma-store" = 0 : i32} {
    %0 = llvm.mlir.constant(true) : i1
    %1 = llvm.mlir.constant(0 : index) : i32
    %2 = llvm.mlir.constant(512 : i32) : i32
    %3 = llvm.mlir.constant(3 : i32) : i32
    %4 = llvm.mlir.constant(2 : i32) : i32
    %5 = llvm.mlir.constant(1024 : i32) : i32
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.mlir.constant(0 : i32) : i32
    %8 = llvm.mlir.constant(256 : i32) : i32
    %9 = llvm.mlir.constant(8 : i32) : i32
    %10 = llvm.mlir.constant(4 : i32) : i32
    %11 = llvm.mlir.constant(32 : i32) : i32
    %12 = genx.workitem.id.x : i32
    %13 = llvm.urem %12, %11  : i32
    %14 = llvm.udiv %12, %11  : i32
    %15 = llvm.urem %14, %10  : i32
    %16 = llvm.urem %13, %11  : i32
    %17 = llvm.urem %15, %9  : i32
    %18 = llvm.urem %16, %8  : i32
    %19 = llvm.mul %17, %11  : i32
    %20 = llvm.add %18, %19  : i32
    %21 = llvm.mul %20, %10  : i32
    %22 = llvm.urem %7, %6  : i32
    %23 = llvm.mul %22, %5  : i32
    %24 = llvm.add %21, %23  : i32
    %25 = llvm.add %24, %7  : i32
    %26 = llvm.add %24, %2  : i32
    %27 = genx.workgroup.id.x : i32
    %28 = llvm.mul %27, %5  : i32
    %29 = llvm.add %25, %1  : i32
    %30 = llvm.add %26, %1  : i32
    %31 = llvm.add %28, %29  : i32
    %32 = llvm.add %28, %30  : i32
    %33 = llvm.icmp "slt" %31, %arg3 : i32
    %34 = llvm.icmp "slt" %32, %arg3 : i32
    %35 = llvm.getelementptr %arg0[%31] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %36 = llvm.getelementptr %arg0[%32] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %37 = llvm.mlir.undef : vector<4xi32>
    llvm.cond_br %33, ^bb1, ^bb2(%37 : vector<4xi32>)
  ^bb1:  // pred: ^bb0
    %38 = llvm.load %35 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb2(%38 : vector<4xi32>)
  ^bb2(%39: vector<4xi32>):  // 2 preds: ^bb0, ^bb1
    %40 = llvm.extractelement %39[%7 : i32] : vector<4xi32>
    %41 = llvm.bitcast %40 : i32 to vector<1xf32>
    %42 = llvm.extractelement %39[%6 : i32] : vector<4xi32>
    %43 = llvm.bitcast %42 : i32 to vector<1xf32>
    %44 = llvm.extractelement %39[%4 : i32] : vector<4xi32>
    %45 = llvm.bitcast %44 : i32 to vector<1xf32>
    %46 = llvm.extractelement %39[%3 : i32] : vector<4xi32>
    %47 = llvm.bitcast %46 : i32 to vector<1xf32>
    %48 = llvm.extractelement %41[%7 : i32] : vector<1xf32>
    %49 = llvm.extractelement %43[%7 : i32] : vector<1xf32>
    %50 = llvm.extractelement %45[%7 : i32] : vector<1xf32>
    %51 = llvm.extractelement %47[%7 : i32] : vector<1xf32>
    llvm.cond_br %34, ^bb3, ^bb4(%37 : vector<4xi32>)
  ^bb3:  // pred: ^bb2
    %52 = llvm.load %36 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb4(%52 : vector<4xi32>)
  ^bb4(%53: vector<4xi32>):  // 2 preds: ^bb2, ^bb3
    %54 = llvm.extractelement %53[%7 : i32] : vector<4xi32>
    %55 = llvm.bitcast %54 : i32 to vector<1xf32>
    %56 = llvm.extractelement %53[%6 : i32] : vector<4xi32>
    %57 = llvm.bitcast %56 : i32 to vector<1xf32>
    %58 = llvm.extractelement %53[%4 : i32] : vector<4xi32>
    %59 = llvm.bitcast %58 : i32 to vector<1xf32>
    %60 = llvm.extractelement %53[%3 : i32] : vector<4xi32>
    %61 = llvm.bitcast %60 : i32 to vector<1xf32>
    %62 = llvm.extractelement %55[%7 : i32] : vector<1xf32>
    %63 = llvm.extractelement %57[%7 : i32] : vector<1xf32>
    %64 = llvm.extractelement %59[%7 : i32] : vector<1xf32>
    %65 = llvm.extractelement %61[%7 : i32] : vector<1xf32>
    %66 = llvm.getelementptr %arg1[%31] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %67 = llvm.getelementptr %arg1[%32] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    llvm.cond_br %33, ^bb5, ^bb6(%37 : vector<4xi32>)
  ^bb5:  // pred: ^bb4
    %68 = llvm.load %66 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb6(%68 : vector<4xi32>)
  ^bb6(%69: vector<4xi32>):  // 2 preds: ^bb4, ^bb5
    %70 = llvm.extractelement %69[%7 : i32] : vector<4xi32>
    %71 = llvm.bitcast %70 : i32 to vector<1xf32>
    %72 = llvm.extractelement %69[%6 : i32] : vector<4xi32>
    %73 = llvm.bitcast %72 : i32 to vector<1xf32>
    %74 = llvm.extractelement %69[%4 : i32] : vector<4xi32>
    %75 = llvm.bitcast %74 : i32 to vector<1xf32>
    %76 = llvm.extractelement %69[%3 : i32] : vector<4xi32>
    %77 = llvm.bitcast %76 : i32 to vector<1xf32>
    %78 = llvm.extractelement %71[%7 : i32] : vector<1xf32>
    %79 = llvm.extractelement %73[%7 : i32] : vector<1xf32>
    %80 = llvm.extractelement %75[%7 : i32] : vector<1xf32>
    %81 = llvm.extractelement %77[%7 : i32] : vector<1xf32>
    llvm.cond_br %34, ^bb7, ^bb8(%37 : vector<4xi32>)
  ^bb7:  // pred: ^bb6
    %82 = llvm.load %67 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb8(%82 : vector<4xi32>)
  ^bb8(%83: vector<4xi32>):  // 2 preds: ^bb6, ^bb7
    %84 = llvm.extractelement %83[%7 : i32] : vector<4xi32>
    %85 = llvm.bitcast %84 : i32 to vector<1xf32>
    %86 = llvm.extractelement %83[%6 : i32] : vector<4xi32>
    %87 = llvm.bitcast %86 : i32 to vector<1xf32>
    %88 = llvm.extractelement %83[%4 : i32] : vector<4xi32>
    %89 = llvm.bitcast %88 : i32 to vector<1xf32>
    %90 = llvm.extractelement %83[%3 : i32] : vector<4xi32>
    %91 = llvm.bitcast %90 : i32 to vector<1xf32>
    %92 = llvm.extractelement %85[%7 : i32] : vector<1xf32>
    %93 = llvm.extractelement %87[%7 : i32] : vector<1xf32>
    %94 = llvm.extractelement %89[%7 : i32] : vector<1xf32>
    %95 = llvm.extractelement %91[%7 : i32] : vector<1xf32>
    %96 = llvm.fadd %48, %78  : f32
    %97 = llvm.fadd %49, %79  : f32
    %98 = llvm.fadd %50, %80  : f32
    %99 = llvm.fadd %51, %81  : f32
    %100 = llvm.fadd %62, %92  : f32
    %101 = llvm.fadd %63, %93  : f32
    %102 = llvm.fadd %64, %94  : f32
    %103 = llvm.fadd %65, %95  : f32
    %104 = llvm.getelementptr %arg2[%31] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %105 = llvm.getelementptr %arg2[%32] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %106 = llvm.mlir.undef : vector<1xf32>
    %107 = llvm.insertelement %96, %106[%7 : i32] : vector<1xf32>
    %108 = llvm.bitcast %107 : vector<1xf32> to i32
    %109 = llvm.insertelement %97, %106[%7 : i32] : vector<1xf32>
    %110 = llvm.bitcast %109 : vector<1xf32> to i32
    %111 = llvm.insertelement %98, %106[%7 : i32] : vector<1xf32>
    %112 = llvm.bitcast %111 : vector<1xf32> to i32
    %113 = llvm.insertelement %99, %106[%7 : i32] : vector<1xf32>
    %114 = llvm.bitcast %113 : vector<1xf32> to i32
    %115 = llvm.and %0, %33  : i1
    %116 = llvm.insertelement %108, %37[%7 : i32] : vector<4xi32>
    %117 = llvm.insertelement %110, %116[%6 : i32] : vector<4xi32>
    %118 = llvm.insertelement %112, %117[%4 : i32] : vector<4xi32>
    %119 = llvm.insertelement %114, %118[%3 : i32] : vector<4xi32>
    llvm.cond_br %115, ^bb9, ^bb10
  ^bb9:  // pred: ^bb8
    llvm.store %119, %104 : vector<4xi32>, !llvm.ptr<1>
    llvm.br ^bb10
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %120 = llvm.insertelement %100, %106[%7 : i32] : vector<1xf32>
    %121 = llvm.bitcast %120 : vector<1xf32> to i32
    %122 = llvm.insertelement %101, %106[%7 : i32] : vector<1xf32>
    %123 = llvm.bitcast %122 : vector<1xf32> to i32
    %124 = llvm.insertelement %102, %106[%7 : i32] : vector<1xf32>
    %125 = llvm.bitcast %124 : vector<1xf32> to i32
    %126 = llvm.insertelement %103, %106[%7 : i32] : vector<1xf32>
    %127 = llvm.bitcast %126 : vector<1xf32> to i32
    %128 = llvm.and %0, %34  : i1
    %129 = llvm.insertelement %121, %37[%7 : i32] : vector<4xi32>
    %130 = llvm.insertelement %123, %129[%6 : i32] : vector<4xi32>
    %131 = llvm.insertelement %125, %130[%4 : i32] : vector<4xi32>
    %132 = llvm.insertelement %127, %131[%3 : i32] : vector<4xi32>
    llvm.cond_br %128, ^bb11, ^bb12
  ^bb11:  // pred: ^bb10
    llvm.store %132, %105 : vector<4xi32>, !llvm.ptr<1>
    llvm.br ^bb12
  ^bb12:  // 2 preds: ^bb10, ^bb11
    llvm.return
  }
}


module attributes {"triton_gpu.compute-capability" = 80 : i32, "triton_gpu.num-ctas" = 1 : i32, "triton_gpu.num-warps" = 4 : i32, triton_gpu.shared = 0 : i32, "triton_gpu.threads-per-warp" = 32 : i32} {
  llvm.func @add_kernel_0d1d2d3de(%arg0: !llvm.ptr<1> {tt.divisibility = 16 : i32}, %arg1: !llvm.ptr<1> {tt.divisibility = 16 : i32}, %arg2: !llvm.ptr<1> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}) attributes {genx.intel_reqd_sub_group_size = [32 : i32], genx.kernel = 1 : i32, genx.max_work_group_size = [128 : i32, 1 : i32, 1 : i32], noinline = false, sym_visibility = "public", "triton_gpu.num-tma-load" = 0 : i32, "triton_gpu.num-tma-store" = 0 : i32} {
    %0 = llvm.mlir.constant(true) : i1
    %1 = llvm.mlir.constant(0 : index) : i32
    %2 = llvm.mlir.constant(512 : i32) : i32
    %3 = llvm.mlir.constant(3 : i32) : i32
    %4 = llvm.mlir.constant(2 : i32) : i32
    %5 = llvm.mlir.constant(1024 : i32) : i32
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.mlir.constant(0 : i32) : i32
    %8 = llvm.mlir.constant(256 : i32) : i32
    %9 = llvm.mlir.constant(8 : i32) : i32
    %10 = llvm.mlir.constant(4 : i32) : i32
    %11 = llvm.mlir.constant(32 : i32) : i32
    %12 = genx.workitem.id.x : i32
    %13 = llvm.urem %12, %11  : i32
    %14 = llvm.udiv %12, %11  : i32
    %15 = llvm.urem %14, %10  : i32
    %16 = llvm.urem %13, %11  : i32
    %17 = llvm.urem %15, %9  : i32
    %18 = llvm.urem %16, %8  : i32
    %19 = llvm.mul %17, %11  : i32
    %20 = llvm.add %18, %19  : i32
    %21 = llvm.mul %20, %10  : i32
    %22 = llvm.urem %7, %6  : i32
    %23 = llvm.mul %22, %5  : i32
    %24 = llvm.add %21, %23  : i32
    %25 = llvm.add %24, %7  : i32
    %26 = llvm.add %24, %2  : i32
    %27 = genx.workgroup.id.x : i32
    %28 = llvm.mul %27, %5  : i32
    %29 = llvm.add %25, %1  : i32
    %30 = llvm.add %26, %1  : i32
    %31 = llvm.add %28, %29  : i32
    %32 = llvm.add %28, %30  : i32
    %33 = llvm.icmp "slt" %31, %arg3 : i32
    %34 = llvm.icmp "slt" %32, %arg3 : i32
    %35 = llvm.getelementptr %arg0[%31] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %36 = llvm.getelementptr %arg0[%32] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %37 = llvm.mlir.undef : vector<4xi32>
    llvm.cond_br %33, ^bb1, ^bb2(%37 : vector<4xi32>)
  ^bb1:  // pred: ^bb0
    %38 = llvm.load %35 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb2(%38 : vector<4xi32>)
  ^bb2(%39: vector<4xi32>):  // 2 preds: ^bb0, ^bb1
    %40 = llvm.extractelement %39[%7 : i32] : vector<4xi32>
    %41 = llvm.bitcast %40 : i32 to vector<1xf32>
    %42 = llvm.extractelement %39[%6 : i32] : vector<4xi32>
    %43 = llvm.bitcast %42 : i32 to vector<1xf32>
    %44 = llvm.extractelement %39[%4 : i32] : vector<4xi32>
    %45 = llvm.bitcast %44 : i32 to vector<1xf32>
    %46 = llvm.extractelement %39[%3 : i32] : vector<4xi32>
    %47 = llvm.bitcast %46 : i32 to vector<1xf32>
    %48 = llvm.extractelement %41[%7 : i32] : vector<1xf32>
    %49 = llvm.extractelement %43[%7 : i32] : vector<1xf32>
    %50 = llvm.extractelement %45[%7 : i32] : vector<1xf32>
    %51 = llvm.extractelement %47[%7 : i32] : vector<1xf32>
    llvm.cond_br %34, ^bb3, ^bb4(%37 : vector<4xi32>)
  ^bb3:  // pred: ^bb2
    %52 = llvm.load %36 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb4(%52 : vector<4xi32>)
  ^bb4(%53: vector<4xi32>):  // 2 preds: ^bb2, ^bb3
    %54 = llvm.extractelement %53[%7 : i32] : vector<4xi32>
    %55 = llvm.bitcast %54 : i32 to vector<1xf32>
    %56 = llvm.extractelement %53[%6 : i32] : vector<4xi32>
    %57 = llvm.bitcast %56 : i32 to vector<1xf32>
    %58 = llvm.extractelement %53[%4 : i32] : vector<4xi32>
    %59 = llvm.bitcast %58 : i32 to vector<1xf32>
    %60 = llvm.extractelement %53[%3 : i32] : vector<4xi32>
    %61 = llvm.bitcast %60 : i32 to vector<1xf32>
    %62 = llvm.extractelement %55[%7 : i32] : vector<1xf32>
    %63 = llvm.extractelement %57[%7 : i32] : vector<1xf32>
    %64 = llvm.extractelement %59[%7 : i32] : vector<1xf32>
    %65 = llvm.extractelement %61[%7 : i32] : vector<1xf32>
    %66 = llvm.getelementptr %arg1[%31] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %67 = llvm.getelementptr %arg1[%32] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    llvm.cond_br %33, ^bb5, ^bb6(%37 : vector<4xi32>)
  ^bb5:  // pred: ^bb4
    %68 = llvm.load %66 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb6(%68 : vector<4xi32>)
  ^bb6(%69: vector<4xi32>):  // 2 preds: ^bb4, ^bb5
    %70 = llvm.extractelement %69[%7 : i32] : vector<4xi32>
    %71 = llvm.bitcast %70 : i32 to vector<1xf32>
    %72 = llvm.extractelement %69[%6 : i32] : vector<4xi32>
    %73 = llvm.bitcast %72 : i32 to vector<1xf32>
    %74 = llvm.extractelement %69[%4 : i32] : vector<4xi32>
    %75 = llvm.bitcast %74 : i32 to vector<1xf32>
    %76 = llvm.extractelement %69[%3 : i32] : vector<4xi32>
    %77 = llvm.bitcast %76 : i32 to vector<1xf32>
    %78 = llvm.extractelement %71[%7 : i32] : vector<1xf32>
    %79 = llvm.extractelement %73[%7 : i32] : vector<1xf32>
    %80 = llvm.extractelement %75[%7 : i32] : vector<1xf32>
    %81 = llvm.extractelement %77[%7 : i32] : vector<1xf32>
    llvm.cond_br %34, ^bb7, ^bb8(%37 : vector<4xi32>)
  ^bb7:  // pred: ^bb6
    %82 = llvm.load %67 : !llvm.ptr<1> -> vector<4xi32>
    llvm.br ^bb8(%82 : vector<4xi32>)
  ^bb8(%83: vector<4xi32>):  // 2 preds: ^bb6, ^bb7
    %84 = llvm.extractelement %83[%7 : i32] : vector<4xi32>
    %85 = llvm.bitcast %84 : i32 to vector<1xf32>
    %86 = llvm.extractelement %83[%6 : i32] : vector<4xi32>
    %87 = llvm.bitcast %86 : i32 to vector<1xf32>
    %88 = llvm.extractelement %83[%4 : i32] : vector<4xi32>
    %89 = llvm.bitcast %88 : i32 to vector<1xf32>
    %90 = llvm.extractelement %83[%3 : i32] : vector<4xi32>
    %91 = llvm.bitcast %90 : i32 to vector<1xf32>
    %92 = llvm.extractelement %85[%7 : i32] : vector<1xf32>
    %93 = llvm.extractelement %87[%7 : i32] : vector<1xf32>
    %94 = llvm.extractelement %89[%7 : i32] : vector<1xf32>
    %95 = llvm.extractelement %91[%7 : i32] : vector<1xf32>
    %96 = llvm.fadd %48, %78  : f32
    %97 = llvm.fadd %49, %79  : f32
    %98 = llvm.fadd %50, %80  : f32
    %99 = llvm.fadd %51, %81  : f32
    %100 = llvm.fadd %62, %92  : f32
    %101 = llvm.fadd %63, %93  : f32
    %102 = llvm.fadd %64, %94  : f32
    %103 = llvm.fadd %65, %95  : f32
    %104 = llvm.getelementptr %arg2[%31] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %105 = llvm.getelementptr %arg2[%32] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32
    %106 = llvm.mlir.undef : vector<1xf32>
    %107 = llvm.insertelement %96, %106[%7 : i32] : vector<1xf32>
    %108 = llvm.bitcast %107 : vector<1xf32> to i32
    %109 = llvm.insertelement %97, %106[%7 : i32] : vector<1xf32>
    %110 = llvm.bitcast %109 : vector<1xf32> to i32
    %111 = llvm.insertelement %98, %106[%7 : i32] : vector<1xf32>
    %112 = llvm.bitcast %111 : vector<1xf32> to i32
    %113 = llvm.insertelement %99, %106[%7 : i32] : vector<1xf32>
    %114 = llvm.bitcast %113 : vector<1xf32> to i32
    %115 = llvm.and %0, %33  : i1
    %116 = llvm.insertelement %108, %37[%7 : i32] : vector<4xi32>
    %117 = llvm.insertelement %110, %116[%6 : i32] : vector<4xi32>
    %118 = llvm.insertelement %112, %117[%4 : i32] : vector<4xi32>
    %119 = llvm.insertelement %114, %118[%3 : i32] : vector<4xi32>
    llvm.cond_br %115, ^bb9, ^bb10
  ^bb9:  // pred: ^bb8
    llvm.store %119, %104 : vector<4xi32>, !llvm.ptr<1>
    llvm.br ^bb10
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %120 = llvm.insertelement %100, %106[%7 : i32] : vector<1xf32>
    %121 = llvm.bitcast %120 : vector<1xf32> to i32
    %122 = llvm.insertelement %101, %106[%7 : i32] : vector<1xf32>
    %123 = llvm.bitcast %122 : vector<1xf32> to i32
    %124 = llvm.insertelement %102, %106[%7 : i32] : vector<1xf32>
    %125 = llvm.bitcast %124 : vector<1xf32> to i32
    %126 = llvm.insertelement %103, %106[%7 : i32] : vector<1xf32>
    %127 = llvm.bitcast %126 : vector<1xf32> to i32
    %128 = llvm.and %0, %34  : i1
    %129 = llvm.insertelement %121, %37[%7 : i32] : vector<4xi32>
    %130 = llvm.insertelement %123, %129[%6 : i32] : vector<4xi32>
    %131 = llvm.insertelement %125, %130[%4 : i32] : vector<4xi32>
    %132 = llvm.insertelement %127, %131[%3 : i32] : vector<4xi32>
    llvm.cond_br %128, ^bb11, ^bb12
  ^bb11:  // pred: ^bb10
    llvm.store %132, %105 : vector<4xi32>, !llvm.ptr<1>
    llvm.br ^bb12
  ^bb12:  // 2 preds: ^bb10, ^bb11
    llvm.return
  }
}

